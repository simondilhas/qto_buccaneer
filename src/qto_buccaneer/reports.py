import pandas as pd
import os
from pathlib import Path
from typing import Optional, Dict, Any
from jinja2 import Environment, FileSystemLoader
import subprocess
from dataclasses import dataclass
import openpyxl
from openpyxl.utils import get_column_letter
from weasyprint import HTML
from datetime import datetime
import pdfkit
import yaml

@dataclass
class ExcelLayoutConfig:
    """Configuration for Excel export layout."""
    horizontal_lines: bool = True
    vertical_lines: bool = False
    bold_headers: bool = True
    auto_column_width: bool = True
    row_height: Optional[float] = None
    alternating_colors: bool = False
    number_format: str = '#,##0.00'
    header_color: str = 'E0E0E0'  # Light gray
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary."""
        return {k: v for k, v in self.__dict__.items()}

@dataclass
class ReportStyleConfig:
    """Configuration for report styling."""
    logo_path: Optional[str] = None
    footer_text: str = "Generated by QTO Buccaneer"
    page_size: str = "A4"
    margin_top: str = "1.5cm"
    margin_bottom: str = "1.5cm"
    margin_left: str = "2cm"
    margin_right: str = "1.5cm"
    font_family: str = "Arial"
    font_size: str = "10pt"
    header_height: str = "2cm"
    footer_height: str = "2cm"
    
    def to_css(self) -> str:
        """Convert config to CSS string."""
        return f"""
            @page {{
                size: {self.page_size};
                margin-top: {self.margin_top};
                margin-bottom: {self.margin_bottom};
                margin-left: {self.margin_left};
                margin-right: {self.margin_right};
                
                @top-center {{
                    content: string(title);
                    font-family: {self.font_family};
                    font-size: {self.font_size};
                }}
                
                @bottom-left {{
                    content: string(project-name);
                    font-family: {self.font_family};
                    font-size: {self.font_size};
                }}
                
                @bottom-right {{
                    content: "Page " counter(page) " of " counter(pages);
                    font-family: {self.font_family};
                    font-size: {self.font_size};
                }}
            }}
            
            body {{
                font-family: {self.font_family};
                font-size: {self.font_size};
                margin: 0;  /* Reset body margin to ensure page margins are used */
            }}
            
            .header {{
                height: {self.header_height};
            }}
            
            .footer {{
                height: {self.footer_height};
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0 1em;
            }}
            
            .footer-left {{
                font-weight: bold;
            }}
            
            .logo {{
                max-height: 2cm;
                max-width: 5cm;
            }}
            
            string(project-name) {{
                content: "{self.footer_text}";
            }}
        """

def export_to_excel(
    df: pd.DataFrame, 
    output_dir: str,
    filename_suffix: str = "metrics",
    building_name: Optional[str] = None,
    layout_config: Optional[ExcelLayoutConfig] = None
) -> str:
    """Export a DataFrame to a new Excel file with optional styling.
    
    Args:
        df (pd.DataFrame): DataFrame to export
        output_dir (str): Directory where the Excel file should be saved
        filename_suffix (str): Suffix to add to the filename (default: "metrics")
        building_name (Optional[str]): Name of the building to include in filename
        layout_config (Optional[ExcelLayoutConfig]): Configuration for Excel styling. 
            If None, uses default ExcelLayoutConfig settings.
            
    Returns:
        str: The path to the exported Excel file
    """
    if df.empty:
        return df
        
    # Use default config if none provided
    if layout_config is None:
        layout_config = ExcelLayoutConfig()
    
    # Create output directory if it doesn't exist
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
    
    # Construct filename
    filename_parts = []
    if building_name:
        filename_parts.append(building_name)
    filename_parts.append(filename_suffix)
    filename = "_".join(filename_parts) + ".xlsx"
    
    # Create full output path
    output_path = os.path.join(output_dir, filename)
    
    # Create Excel writer with the full path
    with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
        # Write DataFrame to Excel
        df.to_excel(writer, index=False, sheet_name='Sheet1')
        
        # Get workbook and worksheet
        workbook = writer.book
        worksheet = writer.sheets['Sheet1']
        
        # Apply styling based on config
        if layout_config.bold_headers:
            for cell in worksheet[1]:
                cell.font = openpyxl.styles.Font(bold=True)
                if layout_config.header_color:
                    cell.fill = openpyxl.styles.PatternFill(
                        start_color=layout_config.header_color,
                        end_color=layout_config.header_color,
                        fill_type='solid'
                    )
        
        # Set number format
        number_format = layout_config.number_format
        for row in worksheet.iter_rows(min_row=2):
            for cell in row:
                if isinstance(cell.value, (int, float)):
                    cell.number_format = number_format
        
        # Set row height if specified
        if layout_config.row_height:
            for row in worksheet.iter_rows():
                worksheet.row_dimensions[row[0].row].height = layout_config.row_height
        
        # Set column widths
        if layout_config.auto_column_width:
            for column in worksheet.columns:
                max_length = 0
                column = [cell for cell in column]
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = (max_length + 2)
                worksheet.column_dimensions[get_column_letter(column[0].column)].width = adjusted_width
        
        # Apply borders
        if layout_config.horizontal_lines or layout_config.vertical_lines:
            for row in worksheet.iter_rows():
                for cell in row:
                    border = openpyxl.styles.Border()
                    if layout_config.horizontal_lines:
                        border.top = openpyxl.styles.Side(style='thin')
                        border.bottom = openpyxl.styles.Side(style='thin')
                    if layout_config.vertical_lines:
                        border.left = openpyxl.styles.Side(style='thin')
                        border.right = openpyxl.styles.Side(style='thin')
                    cell.border = border
        
        # Apply alternating colors if enabled
        if layout_config.alternating_colors:
            for row_idx, row in enumerate(worksheet.iter_rows(min_row=2), start=2):
                if row_idx % 2 == 0:
                    for cell in row:
                        cell.fill = openpyxl.styles.PatternFill(
                            start_color='F0F0F0',
                            end_color='F0F0F0',
                            fill_type='solid'
                        )

    return output_path

def _create_project_comparison_df(df: pd.DataFrame, metrics: Optional[list[str]] = None) -> pd.DataFrame:
    """
    Used by project_comparison() to prepare data for comparison.

    Args:
        df (pd.DataFrame): Input DataFrame containing metrics data
        metrics (Optional[list[str]]): List of metric names to include in the comparison.
            If None, all metrics will be included.

    Returns:
        pd.DataFrame: DataFrame with projects as rows and metrics as columns
        
    Note:
        This is an internal helper function and should not be called directly.
        Use project_comparison() instead.
    """
    required_columns = {'file_name', 'metric_name', 'unit', 'value'}
    missing_columns = required_columns - set(df.columns)
    
    if missing_columns:
        print(f"Warning: Missing required columns: {missing_columns}")  # Debug print
        print(f"Available columns: {df.columns.tolist()}")  # Debug print
        return pd.DataFrame()
        
    try:
        # Filter metrics if a list is provided
        if metrics is not None:
            df = df[df['metric_name'].isin(metrics)].copy()
            
            if df.empty:
                return pd.DataFrame()
        
        # Create a copy to avoid modifying the original DataFrame
        df = df.copy()
        
        # Clean up project names by removing the suffix
        df['file_name'] = df['file_name'].str.replace('_abstractBIM_sp_enriched.ifc', '')
        
        # Create metric names with units
        df['metric_with_unit'] = df['metric_name'] + ' [' + df['unit'] + ']'
        
        pivot_df = df.pivot(
            index='file_name',
            columns='metric_with_unit',
            values='value'
        )
        
        # Only sort if no specific metrics order was provided
        if metrics is None:
            pivot_df = pivot_df.sort_index(axis=1)
        else:
            # Reorder columns based on the provided metrics order
            metric_order = [m + ' [' + df[df['metric_name'] == m]['unit'].iloc[0] + ']' for m in metrics]
            pivot_df = pivot_df[metric_order]
            
        pivot_df = pivot_df.reset_index()
        pivot_df = pivot_df.rename(columns={'file_name': 'Project'})
        
        return pivot_df
        
    except Exception as e:
        return pd.DataFrame()

def _export_project_comparison_excel(
    df: pd.DataFrame, 
    output_path: str, 
    include_metrics: Optional[list[str]] = None,
    layout_config: Optional[ExcelLayoutConfig] = None
) -> pd.DataFrame:
    """
    Helper function to export project comparison to Excel with formatting.
    Used by project_comparison() to handle Excel export.
    
    Args:
        df (pd.DataFrame): Project comparison DataFrame
        output_path (str): Full path where the Excel file should be saved
        include_metrics (Optional[list[str]]): List of metric names to include in the comparison
        layout_config (Optional[ExcelLayoutConfig]): Configuration for Excel layout.
            If None, default settings will be used.
            
    Returns:
        pd.DataFrame: The exported DataFrame
        
    Note:
        This is an internal helper function and should not be called directly.
        Use project_comparison() instead.
    """
    comparison_df = _create_project_comparison_df(df, include_metrics)
    
    print("Input DataFrame shape:", df.shape)  # Debug print
    print("Comparison DataFrame shape:", comparison_df.shape)  # Debug print
    print("Metrics:", include_metrics)  # Debug print
    
    if comparison_df.empty:
        print("Warning: Comparison DataFrame is empty!")  # Debug print
        return comparison_df
        
    # Make sure the output directory exists
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)
        
    try:
        config = layout_config or ExcelLayoutConfig()
        
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            comparison_df.to_excel(writer, index=False, sheet_name='Comparison')
            worksheet = writer.sheets['Comparison']
            
            # Auto-adjust column widths if enabled
            if config.auto_column_width:
                for idx, col in enumerate(comparison_df.columns):
                    max_length = max(
                        comparison_df[col].astype(str).apply(len).max(),
                        len(str(col))
                    )
                    adjusted_width = max_length + 2
                    column_letter = get_column_letter(idx + 1)
                    worksheet.column_dimensions[column_letter].width = adjusted_width
            
            # Set row height if specified
            if config.row_height:
                for row in range(1, len(comparison_df) + 2):
                    worksheet.row_dimensions[row].height = config.row_height
            
            # Add gridlines
            for row in range(1, len(comparison_df) + 2):
                for col in range(1, len(comparison_df.columns) + 1):
                    cell = worksheet.cell(row=row, column=col)
                    borders = {}
                    
                    if config.horizontal_lines:
                        borders['bottom'] = openpyxl.styles.Side(style='thin')
                    if config.vertical_lines:
                        borders['right'] = openpyxl.styles.Side(style='thin')
                    
                    if borders:
                        cell.border = openpyxl.styles.Border(**borders)
                    
                    # Apply number format to numeric cells
                    if row > 1 and col > 1:  # Skip header row and project column
                        try:
                            float(cell.value)  # Check if value is numeric
                            cell.number_format = config.number_format
                        except (TypeError, ValueError):
                            pass
            
            # Format headers
            if config.bold_headers:
                for col in range(1, len(comparison_df.columns) + 1):
                    cell = worksheet.cell(row=1, column=col)
                    cell.font = openpyxl.styles.Font(bold=True)
                    
                    if config.header_color:
                        cell.fill = openpyxl.styles.PatternFill(
                            start_color=config.header_color,
                            end_color=config.header_color,
                            fill_type='solid'
                        )
            
            # Apply alternating colors if enabled
            if config.alternating_colors:
                for row in range(2, len(comparison_df) + 2, 2):  # Start after header
                    for col in range(1, len(comparison_df.columns) + 1):
                        cell = worksheet.cell(row=row, column=col)
                        cell.fill = openpyxl.styles.PatternFill(
                            start_color='F5F5F5',  # Light gray
                            end_color='F5F5F5',
                            fill_type='solid'
                        )

        print(f"Excel file successfully created at: {output_path}")  # Debug print
    except Exception as e:
        print(f"Error creating Excel file: {str(e)}")  # Debug print
        raise
        
    return comparison_df

def room_program_comparison(
    target_excel_path: str,
    ifc_loader,
    room_name_column: str = "LongName",
    target_count_column: Optional[str] = None,
    target_area_column: str = "Target Area/Room",
    ifc_room_name_attribute: str = "LongName",
    ifc_area_attribute: str = "Qto_SpaceBaseQuantities.NetFloorArea",
    output_path: Optional[str] = None,
    layout_config: Optional[ExcelLayoutConfig] = None
) -> pd.DataFrame:
    """
    Create a comparison between target room program and actual IFC spaces.
    
    The function expects a target room program in Excel format with the following structure:
    - One row per room type (e.g., "Office", "Meeting Room", "Bathroom")
    - Columns for room type name and target area per room
    - Optionally a column for target count, or it will be calculated from room names
    
    Args:
        target_excel_path: Path to Excel file containing target room program.
            Expected format: One row per room type with columns for name and area.
        ifc_loader: Instance of IfcLoader with loaded IFC model
        room_name_column: Column name in target Excel for room types (default: "LongName")
        target_count_column: Optional column name for target room count. If None, will be calculated.
        target_area_column: Column name for target area per room (default: "Target Area/Room")
        ifc_room_name_attribute: Attribute name in IFC for room names (default: "LongName")
        ifc_area_attribute: Attribute name in IFC for area values (default: "Qto_SpaceBaseQuantities.NetFloorArea")
        output_path: Optional path to save Excel report
        layout_config: Optional ExcelLayoutConfig for custom formatting
        
    Returns:
        pd.DataFrame: Comparison table with the following metrics for each room type:
            - Target Count: Number of rooms planned (calculated if not provided)
            - Target Area/Room: Planned area per room
            - Target Total Area: Total planned area (count Ã— area/room)
            - Actual Count: Number of rooms in IFC
            - Actual Total Area: Total area in IFC
            - Average Area/Room: Actual average area per room
            - Count Difference: Actual - Target count
            - Area Difference: Actual - Target total area
            - Percentage differences for both count and area
    """
    # Load target room program
    try:
        target_df = pd.read_excel(target_excel_path)
        print(f"Loaded target Excel file. Columns found: {target_df.columns.tolist()}")  # Debug print
        
        # Verify required columns exist
        missing_columns = []
        for col, col_name in [
            (room_name_column, "room name"),
            (target_area_column, "target area")
        ]:
            if col not in target_df.columns:
                missing_columns.append(f"{col_name} ({col})")
        
        if missing_columns:
            raise ValueError(f"Missing required columns in target Excel: {', '.join(missing_columns)}")
            
        # If no target_count_column provided, calculate counts from room names
        if target_count_column is None:
            print("No target count column provided - calculating counts from room names")
            # Group by room name and count occurrences
            count_df = target_df.groupby(room_name_column).size().reset_index(name='Target Count')
            # Merge with original DataFrame
            target_df = pd.merge(target_df, count_df, on=room_name_column)
            target_count_column = 'Target Count'
        elif target_count_column not in target_df.columns:
            raise ValueError(f"Target count column '{target_count_column}' not found in Excel")
            
    except Exception as e:
        print(f"Error loading target Excel file: {str(e)}")
        return pd.DataFrame()
        
    # Get actual spaces from IFC
    try:
        spaces_df = ifc_loader.get_space_information()
        print(f"Loaded spaces from IFC. Found {len(spaces_df)} spaces.")  # Debug print
        
        if spaces_df.empty:
            raise ValueError("No spaces found in IFC model")
            
        # Verify required IFC data columns
        if ifc_room_name_attribute not in spaces_df.columns:
            raise ValueError(f"IFC spaces missing '{ifc_room_name_attribute}' attribute")
        if ifc_area_attribute not in spaces_df.columns:
            raise ValueError(f"IFC spaces missing '{ifc_area_attribute}' quantity")
            
    except Exception as e:
        print(f"Error processing IFC spaces: {str(e)}")
        return pd.DataFrame()
    
    # Initialize result DataFrame
    result = pd.DataFrame()
    
    try:
        # Process each room type from target program
        data = []
        for _, row in target_df.iterrows():
            room_name = row[room_name_column]
            target_count = float(row[target_count_column])  # Convert to float for safety
            target_area = float(row[target_area_column])
            
            print(f"Processing room type: {room_name}")  # Debug print
            
            # Get actual spaces matching this room name
            actual_spaces = spaces_df[spaces_df[ifc_room_name_attribute] == room_name]
            actual_count = len(actual_spaces)
            
            # Sum up actual areas
            actual_total_area = actual_spaces[ifc_area_attribute].sum()
            
            print(f"Found {actual_count} spaces with total area {actual_total_area}")  # Debug print
            
            # Calculate metrics
            target_total_area = target_count * target_area
            avg_area_per_room = actual_total_area / actual_count if actual_count > 0 else 0
            
            count_diff = actual_count - target_count
            count_diff_pct = (count_diff / target_count * 100) if target_count > 0 else 0
            
            area_diff = actual_total_area - target_total_area
            area_diff_pct = (area_diff / target_total_area * 100) if target_total_area > 0 else 0
            
            data.append({
                'Room Type': room_name,
                'Target Count': target_count,
                'Target sqm/room': target_area,
                'Target Total sqm': target_total_area,
                'Actual Count': actual_count,
                'Actual Total sqm': actual_total_area,
                'Avg sqm/room': avg_area_per_room,
                'Count Diff': count_diff,
                '% Count Diff': count_diff_pct,
                'Area Diff': area_diff,
                '% Area Diff': area_diff_pct
            })
            
        result = pd.DataFrame(data)
        
        if result.empty:
            print("No data was processed - empty result DataFrame")
            return pd.DataFrame()
            
        # Add totals row
        totals = {
            'Room Type': 'TOTAL',
            'Target Count': result['Target Count'].sum(),
            'Target Total sqm': result['Target Total sqm'].sum(),
            'Actual Count': result['Actual Count'].sum(),
            'Actual Total sqm': result['Actual Total sqm'].sum(),
            'Count Diff': result['Count Diff'].sum(),
            'Area Diff': result['Area Diff'].sum()
        }
        
        # Calculate weighted averages for percentages
        total_target_count = result['Target Count'].sum()
        total_target_area = result['Target Total sqm'].sum()
        
        if total_target_count > 0:
            totals['% Count Diff'] = (totals['Count Diff'] / total_target_count * 100)
        if total_target_area > 0:
            totals['% Area Diff'] = (totals['Area Diff'] / total_target_area * 100)
            
        # Calculate overall average sqm/room
        if totals['Actual Count'] > 0:
            totals['Avg sqm/room'] = totals['Actual Total sqm'] / totals['Actual Count']
        else:
            totals['Avg sqm/room'] = 0
            
        totals['Target sqm/room'] = totals['Target Total sqm'] / totals['Target Count'] if totals['Target Count'] > 0 else 0
        
        # Append totals row
        result = pd.concat([result, pd.DataFrame([totals])], ignore_index=True)
        
        # Export to Excel if output path is provided
        if output_path:
            result = _export_room_program_comparison(
                df=result,
                output_path=output_path,
                layout_config=layout_config
            )
        
        return result
        
    except Exception as e:
        print(f"Error creating comparison: {str(e)}")
        import traceback
        traceback.print_exc()  # Print full stack trace
        return pd.DataFrame()

def _export_room_program_comparison(
    df: pd.DataFrame,
    output_path: str,
    layout_config: Optional[ExcelLayoutConfig] = None
) -> pd.DataFrame:
    """
    Helper function to export room program comparison to Excel with formatting.
    Used by room_program_comparison() to handle Excel export.
    
    Args:
        df (pd.DataFrame): Room program comparison DataFrame
        output_path (str): Full path where the Excel file should be saved
        layout_config (Optional[ExcelLayoutConfig]): Configuration for Excel layout.
            If None, default settings will be used.
            
    Returns:
        pd.DataFrame: The exported DataFrame
        
    Note:
        This is an internal helper function and should not be called directly.
        Use room_program_comparison() instead.
    """
    if df.empty:
        print("Warning: Input DataFrame is empty!")
        return df
        
    # Make sure the output directory exists
    output_dir = os.path.dirname(output_path)
    if output_dir:  # Only create directory if path contains a directory component
        os.makedirs(output_dir, exist_ok=True)
        
    try:
        # Use provided config or create default one
        config = layout_config or ExcelLayoutConfig(
            horizontal_lines=True,
            vertical_lines=True,
            bold_headers=True,
            auto_column_width=True,
            alternating_colors=True,
            number_format='#,##0.00'
        )
        
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            df.to_excel(writer, index=False, sheet_name='Room Program Comparison')
            worksheet = writer.sheets['Room Program Comparison']
            
            # Auto-adjust column widths
            if config.auto_column_width:
                for idx, col in enumerate(df.columns):
                    max_length = max(
                        df[col].astype(str).apply(len).max(),
                        len(str(col))
                    )
                    adjusted_width = max_length + 2
                    column_letter = get_column_letter(idx + 1)
                    worksheet.column_dimensions[column_letter].width = adjusted_width
            
            # Set row height if specified
            if config.row_height:
                for row in range(1, len(df) + 2):
                    worksheet.row_dimensions[row].height = config.row_height
            
            # Format cells
            for row in range(1, len(df) + 2):
                for col in range(1, len(df.columns) + 1):
                    cell = worksheet.cell(row=row, column=col)
                    
                    # Add borders based on config
                    borders = {}
                    if config.horizontal_lines:
                        borders['bottom'] = openpyxl.styles.Side(style='thin')
                    if config.vertical_lines:
                        borders['right'] = openpyxl.styles.Side(style='thin')
                    if borders:
                        cell.border = openpyxl.styles.Border(**borders)
                    
                    # Format numbers (skip first column - Room Type)
                    if row > 1 and col > 1:
                        try:
                            float(cell.value)  # Check if value is numeric
                            # Use percentage format for % columns
                            if df.columns[col-1].startswith('%'):
                                cell.number_format = '0.00%'
                            else:
                                cell.number_format = config.number_format
                        except (TypeError, ValueError):
                            pass
                    
                    # Format headers
                    if row == 1 and config.bold_headers:
                        cell.font = openpyxl.styles.Font(bold=True)
                        if config.header_color:
                            cell.fill = openpyxl.styles.PatternFill(
                                start_color=config.header_color,
                                end_color=config.header_color,
                                fill_type='solid'
                            )
                    
                    # Format totals row (last row)
                    if row == len(df) + 1:
                        cell.font = openpyxl.styles.Font(bold=True)
                        cell.fill = openpyxl.styles.PatternFill(
                            start_color=config.header_color,
                            end_color=config.header_color,
                            fill_type='solid'
                        )
                    
                    # Apply alternating colors
                    elif config.alternating_colors and row > 1 and row <= len(df):
                        if row % 2 == 0:  # Even rows
                            cell.fill = openpyxl.styles.PatternFill(
                                start_color='F5F5F5',  # Light gray
                                end_color='F5F5F5',
                                fill_type='solid'
                            )

        print(f"Excel file successfully created at: {output_path}")
    except Exception as e:
        print(f"Error creating Excel file: {str(e)}")
        raise
        
    return df

def _convert_html_to_pdf(
    html_content: str, 
    output_path: str,
    style_config: Optional[ReportStyleConfig] = None
) -> str:
    """
    Helper function to convert HTML content to PDF using WeasyPrint with styling.
    Used by generate_metrics_report() to handle PDF conversion.
    
    Args:
        html_content (str): HTML content to convert
        output_path (str): Path where the PDF should be saved
        style_config (Optional[ReportStyleConfig]): Configuration for report styling
        
    Returns:
        str: Path to the generated PDF file
        
    Raises:
        Exception: If PDF conversion fails
        
    Note:
        This is an internal helper function and should not be called directly.
        Use generate_metrics_report() instead.
    """
    try:
        # Use default config if none provided
        style_config = style_config or ReportStyleConfig()
        
        # Add CSS to HTML content
        css = style_config.to_css()
        html_with_css = f"""
            <style>
                {css}
            </style>
            {html_content}
        """
        
        HTML(string=html_with_css).write_pdf(output_path)
        return output_path
    except Exception as e:
        raise Exception(f"Failed to convert HTML to PDF: {str(e)}")

def load_metrics_config() -> dict:
    """
    Load metrics configuration from YAML file.
    
    Returns:
        dict: Configuration dictionary
    """
    # Get the workspace root directory (two levels up from the current file)
    workspace_root = Path(__file__).parent.parent.parent
    config_path = workspace_root / 'src' / 'qto_buccaneer' / 'configs' / 'abstractBIM_report_config.yaml'
    print(f"Loading metrics config from: {config_path}")  # Debug print
    if not config_path.exists():
        raise FileNotFoundError(f"Metrics configuration file not found at: {config_path}")
    
    with open(config_path, 'r') as f:
        config = yaml.safe_load(f)
        print(f"Loaded config sections: {list(config.keys())}")  # Debug print
        return config

def build_metrics_table(
    metrics_df: pd.DataFrame, 
    base_metrics: dict = None,
    include_metrics: list = None,
    language: str = None
) -> dict:
    """
    Build a formatted metrics table from a DataFrame of metrics.
    
    Args:
        metrics_df (pd.DataFrame): DataFrame containing metrics with columns:
            - metric_name: Name of the metric
            - value: Numeric value
            - unit: Unit of measurement
        base_metrics (dict): Dictionary mapping metric names to their base metrics for percentages.
            If None, will use base_metrics from config.
        include_metrics (list): List of metric names to include in the table.
            If None, will use metrics defined in sections from config.
        language (str): Language code to use for display names (e.g., 'en', 'de').
            If None, will use default_language from config.
            
    Returns:
        dict: Dictionary containing sections with their metrics
    """
    print(f"Input metrics_df shape: {metrics_df.shape}")  # Debug print
    print(f"Input metrics_df columns: {metrics_df.columns.tolist()}")  # Debug print
    
    # Load configuration
    config = load_metrics_config()
    
    # Use default language if none specified
    if language is None:
        language = config.get('default_language', 'en')
    print(f"Using language: {language}")  # Debug print
    
    # Get all defined metrics from the configuration
    defined_metrics = set()
    for section in config.get('sections', []):
        if 'metrics' in section:
            defined_metrics.update(section.get('metrics', []))
    
    print(f"Defined metrics in config: {defined_metrics}")  # Debug print
    
    # First filter to only include metrics that exist in the DataFrame
    available_metrics = set(metrics_df['metric_name'].unique())
    print(f"Available metrics in DataFrame: {available_metrics}")  # Debug print
    
    # Determine which metrics to include
    if include_metrics and len(include_metrics) > 0:
        print(f"Using provided include_metrics: {include_metrics}")  # Debug print
        # Convert include_metrics to set for faster lookups
        include_metrics_set = set(include_metrics)
        # Only keep metrics that are both in include_metrics and available_metrics
        filtered_metrics = include_metrics_set.intersection(available_metrics)
        print(f"Metrics after include_metrics filter: {filtered_metrics}")  # Debug print
    else:
        # If no include_metrics provided or empty list, use defined metrics that are available
        filtered_metrics = defined_metrics.intersection(available_metrics)
        print(f"No include_metrics provided, using defined metrics: {filtered_metrics}")  # Debug print
    
    # Filter the DataFrame to only include the filtered metrics
    metrics_df = metrics_df[metrics_df['metric_name'].isin(filtered_metrics)].copy()
    print(f"Final DataFrame shape after filtering: {metrics_df.shape}")  # Debug print
    
    # Use provided base_metrics or load from config
    if base_metrics is None:
        base_metrics = {}
        for metric_id, metric_config in config.get('metrics', {}).items():
            if metric_config.get('base_metric'):
                base_metrics[metric_id] = metric_config['base_metric']
    
    # Get base metric values
    base_values = {}
    for base_metric in set(base_metrics.values()):
        try:
            base_values[base_metric] = metrics_df[metrics_df['metric_name'] == base_metric]['value'].iloc[0]
        except IndexError:
            base_values[base_metric] = 0
    
    # Build metrics table by sections
    result = {}
    for section in config.get('sections', []):
        section_id = section['id']
        section_title = section['title'].get(language, section['title']['en'])
        
        # Handle special sections
        if section_id == 'title_page':
            result[section_id] = {
                'title': section_title,
                'metrics': []  # No metrics for title page
            }
            continue
            
        if section_id == 'table_of_contents':
            result[section_id] = {
                'title': section_title,
                'metrics': []  # No metrics for table of contents
            }
            continue
            
        # Handle metrics sections
        section_metrics = []
        for metric_id in section.get('metrics', []):
            if metric_id not in filtered_metrics:
                continue
                
            metric_config = config['metrics'].get(metric_id, {})
            metric_row = metrics_df[metrics_df['metric_name'] == metric_id].iloc[0]
            
            # Get display name in selected language
            display_name = metric_config['name'].get(language, metric_config['name']['en'])
            
            # Format the value with unit - show just the number for count metrics
            value = metric_row['value']
            unit = metric_row['unit']
            if unit == 'count':
                formatted_value = f"{value}"
            else:
                formatted_value = f"{value:.2f} {unit}"
            
            # Calculate and format percentage if applicable
            percentage = ''
            base_metric = metric_config.get('base_metric')
            if base_metric:
                base_value = base_values.get(base_metric, 0)
                if base_value > 0:
                    pct = (value / base_value) * 100
                    base_name = config['metrics'][base_metric]['name'].get(language, config['metrics'][base_metric]['name']['en'])
                    percentage = config['formatting']['percentage']['format'].format(
                        value=pct,
                        base_name=base_name.split('(')[0].strip(),
                        of_word=config['formatting']['percentage']['languages'].get(language, 'of')
                    )
            
            section_metrics.append({
                'name': display_name,
                'value1': formatted_value,
                'value2': percentage
            })
        
        if section_metrics:  # Only add section if it has metrics
            result[section_id] = {
                'title': section_title,
                'metrics': section_metrics
            }
    
    print(f"Final sections: {list(result.keys())}")  # Debug print
    return result

def generate_metrics_report(
    metrics_df: pd.DataFrame,
    building_name: str,
    plots_dir: str,
    building_adresse: Optional[str] = None,
    building_description: Optional[str] = None,
    output_dir: str = 'reports',
    template_path: str = 'configs/abstractBIM_report_template.html',
    style_config: Optional[ReportStyleConfig] = None,
    report_config_path: str = "abstractBIM_report_config.yaml"
) -> str:
    """
    Generate a metrics report from the provided metrics DataFrame.
    
    Args:
        metrics_df (pd.DataFrame): DataFrame containing the metrics data
        building_name (str): Name of the project, used for the report title
        plots_dir (str): Directory containing report plots
        building_adresse (Optional[str]): Address of the building
        building_description (Optional[str]): Description of the building
        output_dir (str): Directory where the final PDF report will be saved
        template_path (str): Path to the report template HTML file
        style_config (Optional[ReportStyleConfig]): Configuration for report styling
        report_config_path (str): Path to the report configuration YAML file
        
    Returns:
        str: Path to the generated PDF report
    """
    # Get the workspace root directory (two levels up from the current file)
    workspace_root = Path(__file__).parent.parent.parent
    
    # Convert relative paths to absolute paths
    template_file = str(workspace_root / 'src' / 'qto_buccaneer' / template_path)
    plots_dir = str(workspace_root / plots_dir)
    output_dir = str(workspace_root / output_dir)
    
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Construct output file path
    output_file = f"{building_name}_report.pdf"
    output_path = os.path.join(output_dir, output_file)
    
    print(f"Looking for template at: {template_file}")  # Debug print
    
    # Set default image placeholders and formats
    image_placeholders = ['pic_gfa', 'pic_gv', 'pic_project', 'pic_room_floorplan_scale']
    image_formats = ['.png', '.jpg', '.jpeg']
    
    # Collect available images
    images = {}
    for key in image_placeholders:
        found = False
        for ext in image_formats:
            img_path = os.path.join(plots_dir, f"{key}{ext}")
            if os.path.isfile(img_path):
                images[key] = img_path
                found = True
                break
        if not found:
            images[key] = None
    
    # Verify template file exists
    if not os.path.isfile(template_file):
        raise FileNotFoundError(f"Template file not found: {template_file}")
    
    # Load report configuration if provided
    include_metrics = None
    if report_config_path:
        try:
            with open(report_config_path, 'r') as f:
                report_config = yaml.safe_load(f)
                include_metrics = report_config.get('include_metrics', [])
                print(f"Loaded include_metrics from config: {include_metrics}")  # Debug print
        except Exception as e:
            print(f"Warning: Could not load report config: {e}")
    
    # Create metrics table using the build_metrics_table function
    metrics_table = build_metrics_table(metrics_df, include_metrics=include_metrics)
    
    # Render HTML
    template_dir = os.path.dirname(template_file)
    template_name = os.path.basename(template_file)
    env = Environment(loader=FileSystemLoader(template_dir))
    template = env.get_template(template_name)
    
    html_out = template.render(
        project_name=building_name,
        file_name=building_name,
        address=building_adresse or "",
        description=building_description or "",
        date_time=datetime.now().strftime('%Y-%m-%d %H:%M'),
        images=images,
        logo_path=style_config.logo_path if style_config else None,
        metrics_table=metrics_table  # Pass the metrics table to the template
    )
    
    # Save HTML
    html_path = output_path.replace('.pdf', '.html')
    with open(html_path, 'w') as f:
        f.write(html_out)
    
    # Convert to PDF with styling
    try:
        _convert_html_to_pdf(html_out, output_path, style_config)
    except Exception as e:
        print(f"Warning: Could not convert to PDF: {e}")
        print(f"HTML report saved at: {html_path}")
        return html_path
    
    return output_path

def fill_text_line(text: str, width: int = 80, fill_char: str = " ") -> str:
    """
    Fill a text line to a specific width with a fill character.
    
    Args:
        text (str): The text to fill
        width (int): The total width of the line
        fill_char (str): The character to use for filling
        
    Returns:
        str: The filled text line
    """
    if not text:
        return fill_char * width
        
    # Split text into words
    words = text.split()
    if not words:
        return fill_char * width
        
    # Start with the first word
    lines = [words[0]]
    current_length = len(words[0])
    
    # Add remaining words
    for word in words[1:]:
        # If adding the word would exceed the width, start a new line
        if current_length + len(word) + 1 > width:
            lines.append(word)
            current_length = len(word)
        else:
            # Add the word to the current line
            lines[-1] += " " + word
            current_length += len(word) + 1
            
    # Fill each line to the specified width
    filled_lines = []
    for line in lines:
        # Calculate how many fill characters to add
        fill_count = width - len(line)
        if fill_count > 0:
            filled_line = line + (fill_char * fill_count)
        else:
            filled_line = line
        filled_lines.append(filled_line)
        
    return "\n".join(filled_lines)

def format_definition_line(term: str, definition: str, width: int = 80) -> str:
    """
    Format a definition line with the term and definition.
    
    Args:
        term (str): The term being defined
        definition (str): The definition of the term
        width (int): The total width of the line
        
    Returns:
        str: The formatted definition line
    """
    # Create the line with term and definition
    line = f"{term}: {definition}"
    return fill_text_line(line, width)

def format_disclaimer(disclaimer: str, width: int = 80) -> str:
    """
    Format the disclaimer text.
    
    Args:
        disclaimer (str): The disclaimer text
        width (int): The total width of the line
        
    Returns:
        str: The formatted disclaimer
    """
    return fill_text_line(disclaimer, width)

# Example usage in the template rendering:
def render_template_with_filled_text(template, context):
    """
    Render the template with filled text lines.
    
    Args:
        template: The Jinja2 template
        context (dict): The context for the template
        
    Returns:
        str: The rendered template with filled text
    """
    # Format definitions
    definitions = [
        ("Gross Floor Area (GFA)", "The total area of all floors in a building, measured from the exterior walls."),
        ("Gross Volume (GV)", "The total volume of the building, including all enclosed spaces."),
        ("Net Floor Area (NFA)", "The usable area within the building, excluding walls."),
        ("Net Volume (NV)", "The volume of usable space within the building."),
        ("Construction Area", "Difference between GFA and NFA."),
        ("Construction Volume", "Difference between GV and NV."),
        ("Facade Area (FA)", "The total exterior surface area of the building envelope."),
        ("Room Type", "A classification of rooms based on their intended function."),
        ("Spatial Relationships", "Position between elements (e.g., a window relating to a room)."),
        ("Storey", "A horizontal division of a building."),
        ("Baseplate", "The foundational slab at the bottom of the building."),
        ("Covering Area", "Area of facade elements like cladding and panels.")
    ]
    
    # Format each definition
    formatted_definitions = [
        format_definition_line(term, definition)
        for term, definition in definitions
    ]
    
    # Format disclaimer
    disclaimer = "These quantities were generated automatically using the abstractBIM system. Accuracy depends on input quality. The general terms and conditions of abstract AG apply."
    formatted_disclaimer = format_disclaimer(disclaimer)
    
    # Add formatted text to context
    context.update({
        'formatted_definitions': formatted_definitions,
        'formatted_disclaimer': formatted_disclaimer
    })
    
    return template.render(context)

def project_comparison(
    df: pd.DataFrame,
    output_path: Optional[str] = None,
    include_metrics: Optional[list[str]] = None,
    layout_config: Optional[ExcelLayoutConfig] = None
) -> pd.DataFrame:
    """
    Create and optionally export a project comparison DataFrame.
    
    Args:
        df (pd.DataFrame): Input DataFrame containing metrics data
        output_path (Optional[str]): Optional path to save Excel report
        include_metrics (Optional[list[str]]): List of metric names to include in the comparison
        layout_config (Optional[ExcelLayoutConfig]): Configuration for Excel layout.
            If None, default settings will be used.
            
    Returns:
        pd.DataFrame: Comparison table with projects as rows and metrics as columns
    """
    try:
        # Create the comparison DataFrame
        result = _create_project_comparison_df(df, include_metrics)
        
        if result.empty:
            print("No data was processed - empty result DataFrame")
            return pd.DataFrame()
            
        # Export to Excel if output path is provided
        if output_path:
            result = _export_project_comparison_excel(
                df=result,
                output_path=output_path,
                include_metrics=include_metrics,
                layout_config=layout_config
            )
        
        return result
        
    except Exception as e:
        print(f"Error creating comparison: {str(e)}")
        import traceback
        traceback.print_exc()  # Print full stack trace
        return pd.DataFrame()

def create_room_program_from_excel(
    input_excel_path: str,
    room_name_column: str = "LongName",
    area_column: str = "NetFloorArea",
    count_column: Optional[str] = None,
    output_path: Optional[str] = None,
    layout_config: Optional[ExcelLayoutConfig] = None
) -> pd.DataFrame:
    """
    Convert an Excel file with individual rooms into an aggregated room program format.
    
    This function takes an Excel file containing individual rooms and aggregates them by room type,
    calculating the count and average area for each type. The output format matches
    what is expected by room_program_comparison().
    
    Args:
        input_excel_path: Path to Excel file containing individual rooms.
            Each row should represent one room with at least:
            - A room type/name column (default: "LongName")
            - An area column (default: "NetFloorArea")
            - Optionally a count column if rooms are already grouped
        room_name_column: Column name in input Excel for the room type/name
        area_column: Column name in input Excel for the area value
        count_column: Optional column name for room count. If provided, uses this instead of counting rows.
        output_path: Optional path to save the aggregated room program as Excel
        layout_config: Optional ExcelLayoutConfig for custom formatting
        
    Returns:
        pd.DataFrame: Aggregated room program with columns:
            - Room Type (from room_name_column)
            - Target Count (number of rooms of each type)
            - Target Area/Room (average area per room type)
            
    Example:
        Input Excel format:
        | LongName | Soll m2 | Soll Anzahl | Other columns... |
        |----------|---------|-------------|------------------|
        | Office   | 20.0    | 2           | ...              |
        | Meeting  | 30.0    | 1           | ...              |
        
        Output DataFrame:
        | Room Type | Target Count | Target Area/Room |
        |-----------|--------------|------------------|
        | Office    | 2           | 20.0            |
        | Meeting   | 1           | 30.0            |
    """
    try:
        # Load input Excel file
        df = pd.read_excel(input_excel_path)
        
        if df.empty:
            raise ValueError("Input Excel file is empty")
            
        # Verify required columns exist
        missing_columns = []
        for col, col_name in [
            (room_name_column, "room name"),
            (area_column, "area")
        ]:
            if col not in df.columns:
                missing_columns.append(f"{col_name} ({col})")
                
        if missing_columns:
            raise ValueError(f"Missing required columns in input Excel: {', '.join(missing_columns)}")
            
        # If count_column is provided, use it directly
        if count_column:
            if count_column not in df.columns:
                raise ValueError(f"Count column '{count_column}' not found in input Excel")
                
            # Group by room type and use provided count
            result = df.groupby(room_name_column).agg({
                count_column: 'sum',
                area_column: 'mean'
            }).reset_index()
            
            # Rename columns to match expected output format
            result.columns = [room_name_column, 'Target Count', 'Target Area/Room']
            
        else:
            # Group by room type and calculate metrics
            result = df.groupby(room_name_column).agg({
                area_column: ['count', 'mean']
            }).reset_index()
            
            # Flatten multi-index columns
            result.columns = [room_name_column, 'Target Count', 'Target Area/Room']
        
        # Round area to 2 decimal places
        result['Target Area/Room'] = result['Target Area/Room'].round(2)
        
        # Export to Excel if path provided
        if output_path:
            # Create output directory if it doesn't exist
            output_dir = os.path.dirname(output_path)
            if output_dir and not os.path.exists(output_dir):
                os.makedirs(output_dir)
                
            # Use default config if none provided
            config = layout_config or ExcelLayoutConfig(
                horizontal_lines=True,
                vertical_lines=True,
                bold_headers=True,
                auto_column_width=True
            )
            
            with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
                result.to_excel(writer, index=False, sheet_name='Room Program')
                worksheet = writer.sheets['Room Program']
                
                # Apply styling based on config
                if config.bold_headers:
                    for cell in worksheet[1]:
                        cell.font = openpyxl.styles.Font(bold=True)
                        if config.header_color:
                            cell.fill = openpyxl.styles.PatternFill(
                                start_color=config.header_color,
                                end_color=config.header_color,
                                fill_type='solid'
                            )
                
                # Set number format
                number_format = config.number_format
                for row in worksheet.iter_rows(min_row=2):
                    for cell in row:
                        if isinstance(cell.value, (int, float)):
                            cell.number_format = number_format
                
                # Auto-adjust column widths
                if config.auto_column_width:
                    for column in worksheet.columns:
                        max_length = 0
                        column = [cell for cell in column]
                        for cell in column:
                            try:
                                if len(str(cell.value)) > max_length:
                                    max_length = len(str(cell.value))
                            except:
                                pass
                        adjusted_width = (max_length + 2)
                        worksheet.column_dimensions[get_column_letter(column[0].column)].width = adjusted_width
        
        return result
        
    except Exception as e:
        print(f"Error creating room program: {str(e)}")
        import traceback
        traceback.print_exc()
        return pd.DataFrame()

def group_rooms_by_name(
    input_excel_path: str,
    input_room_name_column: str = "LongName",
    input_area_column: str = "Soll m2",
    output_room_name_column: str = "Room Type",
    output_area_column: str = "Area",
    output_count_column: str = "Soll Anzahl",
    output_path: Optional[str] = None,
    layout_config: Optional[ExcelLayoutConfig] = None
) -> pd.DataFrame:
    """
    Group rooms by name and calculate aggregated metrics.
    
    This function takes an Excel file containing individual rooms and:
    1. Groups them by room name
    2. Counts the number of rooms in each group (minimum 1)
    3. Sums the area values for each group (NaN for rooms without area)
    
    Args:
        input_excel_path: Path to Excel file containing individual rooms
        input_room_name_column: Column name for room types/names in input file
        input_area_column: Column name for area values in input file
        output_room_name_column: Column name for room types/names in output
        output_area_column: Column name for area values in output
        output_count_column: Column name for count values in output
        output_path: Optional path to save the results as Excel
        layout_config: Optional ExcelLayoutConfig for custom formatting
        
    Returns:
        pd.DataFrame: Aggregated room program with columns:
            - {output_room_name_column} (from input_room_name_column)
            - {output_area_column} (sum of areas for each room type, NaN for rooms without area)
            - {output_count_column} (number of rooms of each type, minimum 1)
    """
    try:
        # Load input Excel file
        df = pd.read_excel(input_excel_path)
        
        if df.empty:
            raise ValueError("Input Excel file is empty")
            
        # Verify required columns exist
        missing_columns = []
        for col, col_name in [
            (input_room_name_column, "room name"),
            (input_area_column, "area")
        ]:
            if col not in df.columns:
                missing_columns.append(f"{col_name} ({col})")
                
        if missing_columns:
            raise ValueError(f"Missing required columns in input Excel: {', '.join(missing_columns)}")
            
        # Group by room name and calculate metrics
        result = df.groupby(input_room_name_column).agg({
            input_area_column: lambda x: x.sum() if not x.isna().all() else pd.NA  # Sum areas, return NA if all are NA
        }).reset_index()
        
        # Add count column (count all rooms, minimum 1)
        result[output_count_column] = df.groupby(input_room_name_column).size().clip(lower=1).values
        
        # Rename columns for clarity
        result.columns = [output_room_name_column, output_area_column, output_count_column]
        
        # Export to Excel if path provided
        if output_path:
            # Create output directory if it doesn't exist
            output_dir = os.path.dirname(output_path)
            if output_dir and not os.path.exists(output_dir):
                os.makedirs(output_dir)
                
            # Use default config if none provided
            config = layout_config or ExcelLayoutConfig(
                horizontal_lines=True,
                vertical_lines=True,
                bold_headers=True,
                auto_column_width=True
            )
            
            with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
                result.to_excel(writer, index=False, sheet_name='Room Program')
                worksheet = writer.sheets['Room Program']
                
                # Apply styling based on config
                if config.bold_headers:
                    for cell in worksheet[1]:
                        cell.font = openpyxl.styles.Font(bold=True)
                        if config.header_color:
                            cell.fill = openpyxl.styles.PatternFill(
                                start_color=config.header_color,
                                end_color=config.header_color,
                                fill_type='solid'
                            )
                
                # Set number format
                number_format = config.number_format
                for row in worksheet.iter_rows(min_row=2):
                    for cell in row:
                        if isinstance(cell.value, (int, float)):
                            cell.number_format = number_format
                
                # Auto-adjust column widths
                if config.auto_column_width:
                    for column in worksheet.columns:
                        max_length = 0
                        column = [cell for cell in column]
                        for cell in column:
                            try:
                                if len(str(cell.value)) > max_length:
                                    max_length = len(str(cell.value))
                            except:
                                pass
                        adjusted_width = (max_length + 2)
                        worksheet.column_dimensions[get_column_letter(column[0].column)].width = adjusted_width
        
        return result
        
    except Exception as e:
        print(f"Error grouping rooms: {str(e)}")
        import traceback
        traceback.print_exc()
        return pd.DataFrame()

def compare_room_names(
    metadata_actual_df: pd.DataFrame,
    target_program_df: pd.DataFrame,
    target_room_name_column: str = "Raumtypenname",
    actual_room_name_column: str = "Name",
    output_dir: Optional[str] = None,
    building_name: Optional[str] = None,
    layout_config: Optional[ExcelLayoutConfig] = None
) -> pd.DataFrame:
    """
    Compare room names between IFC spaces and a room program.
    
    This function:
    1. Filters IFC spaces from the metadata DataFrame
    2. Gets all unique room names from both sources
    3. Compares the two sets and identifies:
       - Rooms in IFC but not in Excel
       - Rooms in Excel but not in IFC
       - Rooms present in both
    4. Creates two Excel files:
       - All room name comparisons
       - Project-specific rooms (only in IFC)
    
    Args:
        metadata_actual_df: DataFrame containing IFC metadata including spaces (actual state)
        target_program_df: DataFrame containing room program information (target state)
        target_room_name_column: Column name in Excel containing target room names (default: "Raumtypenname")
        actual_room_name_column: Column name in IFC containing actual room names (default: "Name")
        output_dir: Directory where Excel files should be saved
        building_name: Name of the building (used in output filenames)
        layout_config: Optional ExcelLayoutConfig for custom formatting
        
    Returns:
        pd.DataFrame: Comparison table with columns:
            - Room Name: Name of the room
            - Status: One of:
                * "Only in IFC" - Room exists in IFC but not in Excel
                * "Only in Excel" - Room exists in Excel but not in IFC
                * "In Both" - Room exists in both files
    """
    try:
        # Create output paths if directory is provided
        if output_dir:
            os.makedirs(output_dir, exist_ok=True)
            building_prefix = f"{building_name}_" if building_name else ""
            output_path = os.path.join(output_dir, f"{building_prefix}room_name_comparison.xlsx")
            project_specific_output_path = os.path.join(output_dir, f"{building_prefix}project_specific_rooms.xlsx")
        else:
            output_path = None
            project_specific_output_path = None

        # Filter for IFC spaces
        ifc_spaces_df = metadata_actual_df[metadata_actual_df['IfcEntity'] == 'IfcSpace']
        
        # Get room names from IFC and convert to lowercase, filtering out None values
        ifc_rooms = set(ifc_spaces_df[actual_room_name_column].dropna().str.lower().unique())
        
        # Get room names from Excel and convert to lowercase, filtering out None values
        excel_rooms = set(target_program_df[target_room_name_column].dropna().str.lower().unique())
        
        # Create comparison DataFrame
        all_rooms = ifc_rooms.union(excel_rooms)
        data = []
        project_specific_rooms = []
        
        for room in sorted(all_rooms):
            if room in ifc_rooms and room in excel_rooms:
                status = "In Both"
            elif room in ifc_rooms:
                status = "Only in IFC"
                project_specific_rooms.append(room)
            else:
                status = "Only in Excel"
                
            data.append({
                "Room Name": room,
                "Status": status
            })
            
        result = pd.DataFrame(data)
        
        # Create project-specific rooms DataFrame
        project_specific_df = pd.DataFrame({
            "Project Specific Room Name": sorted(project_specific_rooms)
        })
        
        # Export comparison to Excel if path provided
        if output_path:
            # Use default config if none provided
            config = layout_config or ExcelLayoutConfig(
                horizontal_lines=True,
                vertical_lines=True,
                bold_headers=True,
                auto_column_width=True
            )
            
            with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
                result.to_excel(writer, index=False, sheet_name='Room Name Comparison')
                worksheet = writer.sheets['Room Name Comparison']
                
                # Apply styling based on config
                if config.bold_headers:
                    for cell in worksheet[1]:
                        cell.font = openpyxl.styles.Font(bold=True)
                        if config.header_color:
                            cell.fill = openpyxl.styles.PatternFill(
                                start_color=config.header_color,
                                end_color=config.header_color,
                                fill_type='solid'
                            )
                
                # Auto-adjust column widths
                if config.auto_column_width:
                    for column in worksheet.columns:
                        max_length = 0
                        column = [cell for cell in column]
                        for cell in column:
                            try:
                                if len(str(cell.value)) > max_length:
                                    max_length = len(str(cell.value))
                            except:
                                pass
                        adjusted_width = (max_length + 2)
                        worksheet.column_dimensions[get_column_letter(column[0].column)].width = adjusted_width
        
        # Export project-specific rooms to Excel if path provided
        if project_specific_output_path:
            # Use default config if none provided
            config = layout_config or ExcelLayoutConfig(
                horizontal_lines=True,
                vertical_lines=True,
                bold_headers=True,
                auto_column_width=True
            )
            
            with pd.ExcelWriter(project_specific_output_path, engine='openpyxl') as writer:
                project_specific_df.to_excel(writer, index=False, sheet_name='Project Specific Rooms')
                worksheet = writer.sheets['Project Specific Rooms']
                
                # Apply styling based on config
                if config.bold_headers:
                    for cell in worksheet[1]:
                        cell.font = openpyxl.styles.Font(bold=True)
                        if config.header_color:
                            cell.fill = openpyxl.styles.PatternFill(
                                start_color=config.header_color,
                                end_color=config.header_color,
                                fill_type='solid'
                            )
                
                # Auto-adjust column widths
                if config.auto_column_width:
                    for column in worksheet.columns:
                        max_length = 0
                        column = [cell for cell in column]
                        for cell in column:
                            try:
                                if len(str(cell.value)) > max_length:
                                    max_length = len(str(cell.value))
                            except:
                                pass
                        adjusted_width = (max_length + 2)
                        worksheet.column_dimensions[get_column_letter(column[0].column)].width = adjusted_width
        
        return result
        
    except Exception as e:
        print(f"Error comparing room names: {str(e)}")
        import traceback
        traceback.print_exc()
        return pd.DataFrame()

