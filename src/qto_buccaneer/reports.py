import pandas as pd
import os
from pathlib import Path
from typing import Optional, Dict, Any
from jinja2 import Environment, FileSystemLoader
import subprocess
from dataclasses import dataclass
import openpyxl
from openpyxl.utils import get_column_letter
from weasyprint import HTML
from datetime import datetime
import pdfkit
import yaml

@dataclass
class ExcelLayoutConfig:
    """Configuration for Excel export layout."""
    horizontal_lines: bool = True
    vertical_lines: bool = False
    bold_headers: bool = True
    auto_column_width: bool = True
    row_height: Optional[float] = None
    alternating_colors: bool = False
    number_format: str = '#,##0.00'
    header_color: str = 'E0E0E0'  # Light gray
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary."""
        return {k: v for k, v in self.__dict__.items()}

@dataclass
class ReportStyleConfig:
    """Configuration for report styling."""
    logo_path: Optional[str] = None
    footer_text: str = "Generated by QTO Buccaneer"
    page_size: str = "A4"
    margin_top: str = "1.5cm"
    margin_bottom: str = "1.5cm"
    margin_left: str = "2cm"
    margin_right: str = "1.5cm"
    font_family: str = "Arial"
    font_size: str = "10pt"
    header_height: str = "2cm"
    footer_height: str = "2cm"
    
    def to_css(self) -> str:
        """Convert config to CSS string."""
        return f"""
            @page {{
                size: {self.page_size};
                margin-top: {self.margin_top};
                margin-bottom: {self.margin_bottom};
                margin-left: {self.margin_left};
                margin-right: {self.margin_right};
                
                @top-center {{
                    content: string(title);
                    font-family: {self.font_family};
                    font-size: {self.font_size};
                }}
                
                @bottom-left {{
                    content: string(project-name);
                    font-family: {self.font_family};
                    font-size: {self.font_size};
                }}
                
                @bottom-right {{
                    content: "Page " counter(page) " of " counter(pages);
                    font-family: {self.font_family};
                    font-size: {self.font_size};
                }}
            }}
            
            body {{
                font-family: {self.font_family};
                font-size: {self.font_size};
                margin: 0;  /* Reset body margin to ensure page margins are used */
            }}
            
            .header {{
                height: {self.header_height};
            }}
            
            .footer {{
                height: {self.footer_height};
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0 1em;
            }}
            
            .footer-left {{
                font-weight: bold;
            }}
            
            .logo {{
                max-height: 2cm;
                max-width: 5cm;
            }}
            
            string(project-name) {{
                content: "{self.footer_text}";
            }}
        """

def export_to_excel(
    df: pd.DataFrame, 
    output_dir: str,
    filename_suffix: str = "metrics",
    building_name: Optional[str] = None,
    layout_config: Optional[ExcelLayoutConfig] = None
) -> str:
    """Export a DataFrame to a new Excel file with optional styling.
    
    Args:
        df (pd.DataFrame): DataFrame to export
        output_dir (str): Directory where the Excel file should be saved
        filename_suffix (str): Suffix to add to the filename (default: "metrics")
        building_name (Optional[str]): Name of the building to include in filename
        layout_config (Optional[ExcelLayoutConfig]): Configuration for Excel styling. 
            If None, uses default ExcelLayoutConfig settings.
            
    Returns:
        str: The path to the exported Excel file
    """
    if df.empty:
        return df
        
    # Use default config if none provided
    if layout_config is None:
        layout_config = ExcelLayoutConfig()
    
    # Create output directory if it doesn't exist
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
    
    # Construct filename
    filename_parts = []
    if building_name:
        filename_parts.append(building_name)
    filename_parts.append(filename_suffix)
    filename = "_".join(filename_parts) + ".xlsx"
    
    # Create full output path
    output_path = os.path.join(output_dir, filename)
    
    # Create Excel writer with the full path
    with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
        # Write DataFrame to Excel
        df.to_excel(writer, index=False, sheet_name='Sheet1')
        
        # Get workbook and worksheet
        workbook = writer.book
        worksheet = writer.sheets['Sheet1']
        
        # Apply styling based on config
        if layout_config.bold_headers:
            for cell in worksheet[1]:
                cell.font = openpyxl.styles.Font(bold=True)
                if layout_config.header_color:
                    cell.fill = openpyxl.styles.PatternFill(
                        start_color=layout_config.header_color,
                        end_color=layout_config.header_color,
                        fill_type='solid'
                    )
        
        # Set number format
        number_format = layout_config.number_format
        for row in worksheet.iter_rows(min_row=2):
            for cell in row:
                if isinstance(cell.value, (int, float)):
                    cell.number_format = number_format
        
        # Set row height if specified
        if layout_config.row_height:
            for row in worksheet.iter_rows():
                worksheet.row_dimensions[row[0].row].height = layout_config.row_height
        
        # Set column widths
        if layout_config.auto_column_width:
            for column in worksheet.columns:
                max_length = 0
                column = [cell for cell in column]
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = (max_length + 2)
                worksheet.column_dimensions[get_column_letter(column[0].column)].width = adjusted_width
        
        # Apply borders
        if layout_config.horizontal_lines or layout_config.vertical_lines:
            for row in worksheet.iter_rows():
                for cell in row:
                    border = openpyxl.styles.Border()
                    if layout_config.horizontal_lines:
                        border.top = openpyxl.styles.Side(style='thin')
                        border.bottom = openpyxl.styles.Side(style='thin')
                    if layout_config.vertical_lines:
                        border.left = openpyxl.styles.Side(style='thin')
                        border.right = openpyxl.styles.Side(style='thin')
                    cell.border = border
        
        # Apply alternating colors if enabled
        if layout_config.alternating_colors:
            for row_idx, row in enumerate(worksheet.iter_rows(min_row=2), start=2):
                if row_idx % 2 == 0:
                    for cell in row:
                        cell.fill = openpyxl.styles.PatternFill(
                            start_color='F0F0F0',
                            end_color='F0F0F0',
                            fill_type='solid'
                        )

    return output_path

def create_project_comparison_df(df: pd.DataFrame, metrics: Optional[list[str]] = None) -> pd.DataFrame:
    """
    Create a comparison DataFrame with projects as rows and metrics as columns.

    Args:
        df (pd.DataFrame): Input DataFrame containing metrics data
        metrics (Optional[list[str]]): List of metric names to include in the comparison.
            If None, all metrics will be included.

    Returns:
        pd.DataFrame: DataFrame with projects as rows and metrics as columns
    """
    required_columns = {'file_name', 'metric_name', 'unit', 'value'}
    missing_columns = required_columns - set(df.columns)
    
    if missing_columns:
        print(f"Warning: Missing required columns: {missing_columns}")  # Debug print
        print(f"Available columns: {df.columns.tolist()}")  # Debug print
        return pd.DataFrame()
        
    try:
        # Filter metrics if a list is provided
        if metrics is not None:
            df = df[df['metric_name'].isin(metrics)].copy()
            
            if df.empty:
                return pd.DataFrame()
        
        # Create a copy to avoid modifying the original DataFrame
        df = df.copy()
        
        # Clean up project names by removing the suffix
        df['file_name'] = df['file_name'].str.replace('_abstractBIM_sp_enriched.ifc', '')
        
        # Create metric names with units
        df['metric_with_unit'] = df['metric_name'] + ' [' + df['unit'] + ']'
        
        pivot_df = df.pivot(
            index='file_name',
            columns='metric_with_unit',
            values='value'
        )
        
        # Only sort if no specific metrics order was provided
        if metrics is None:
            pivot_df = pivot_df.sort_index(axis=1)
        else:
            # Reorder columns based on the provided metrics order
            metric_order = [m + ' [' + df[df['metric_name'] == m]['unit'].iloc[0] + ']' for m in metrics]
            pivot_df = pivot_df[metric_order]
            
        pivot_df = pivot_df.reset_index()
        pivot_df = pivot_df.rename(columns={'file_name': 'Project'})
        
        return pivot_df
        
    except Exception as e:
        return pd.DataFrame()



def export_project_comparison_excel(
    df: pd.DataFrame, 
    output_path: str, 
    include_metrics: Optional[list[str]] = None,
    layout_config: Optional[ExcelLayoutConfig] = None
) -> pd.DataFrame:
    """
    Create and export project comparison to Excel file with customizable formatting.

    Args:
        df (pd.DataFrame): Input DataFrame containing metrics data
        output_path (str): Full path where the Excel file should be saved
        include_metrics (Optional[list[str]]): List of metric names to include in the comparison
        layout_config (Optional[ExcelLayoutConfig]): Configuration for Excel layout.
            If None, default settings will be used.
            
    Returns:
        pd.DataFrame: The comparison DataFrame that was exported
    """
    comparison_df = create_project_comparison_df(df, include_metrics)
    
    print("Input DataFrame shape:", df.shape)  # Debug print
    print("Comparison DataFrame shape:", comparison_df.shape)  # Debug print
    print("Metrics:", include_metrics)  # Debug print
    
    if comparison_df.empty:
        print("Warning: Comparison DataFrame is empty!")  # Debug print
        return comparison_df
        
    # Make sure the output directory exists
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)
        
    try:
        config = layout_config or ExcelLayoutConfig()
        
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            comparison_df.to_excel(writer, index=False, sheet_name='Comparison')
            worksheet = writer.sheets['Comparison']
            
            # Auto-adjust column widths if enabled
            if config.auto_column_width:
                for idx, col in enumerate(comparison_df.columns):
                    max_length = max(
                        comparison_df[col].astype(str).apply(len).max(),
                        len(str(col))
                    )
                    adjusted_width = max_length + 2
                    column_letter = get_column_letter(idx + 1)
                    worksheet.column_dimensions[column_letter].width = adjusted_width
            
            # Set row height if specified
            if config.row_height:
                for row in range(1, len(comparison_df) + 2):
                    worksheet.row_dimensions[row].height = config.row_height
            
            # Add gridlines
            for row in range(1, len(comparison_df) + 2):
                for col in range(1, len(comparison_df.columns) + 1):
                    cell = worksheet.cell(row=row, column=col)
                    borders = {}
                    
                    if config.horizontal_lines:
                        borders['bottom'] = openpyxl.styles.Side(style='thin')
                    if config.vertical_lines:
                        borders['right'] = openpyxl.styles.Side(style='thin')
                    
                    if borders:
                        cell.border = openpyxl.styles.Border(**borders)
                    
                    # Apply number format to numeric cells
                    if row > 1 and col > 1:  # Skip header row and project column
                        try:
                            float(cell.value)  # Check if value is numeric
                            cell.number_format = config.number_format
                        except (TypeError, ValueError):
                            pass
            
            # Format headers
            if config.bold_headers:
                for col in range(1, len(comparison_df.columns) + 1):
                    cell = worksheet.cell(row=1, column=col)
                    cell.font = openpyxl.styles.Font(bold=True)
                    
                    if config.header_color:
                        cell.fill = openpyxl.styles.PatternFill(
                            start_color=config.header_color,
                            end_color=config.header_color,
                            fill_type='solid'
                        )
            
            # Apply alternating colors if enabled
            if config.alternating_colors:
                for row in range(2, len(comparison_df) + 2, 2):  # Start after header
                    for col in range(1, len(comparison_df.columns) + 1):
                        cell = worksheet.cell(row=row, column=col)
                        cell.fill = openpyxl.styles.PatternFill(
                            start_color='F5F5F5',  # Light gray
                            end_color='F5F5F5',
                            fill_type='solid'
                        )

        print(f"Excel file successfully created at: {output_path}")  # Debug print
    except Exception as e:
        print(f"Error creating Excel file: {str(e)}")  # Debug print
        raise
        
    return comparison_df

def room_program_comparison(
    target_excel_path: str,
    ifc_loader,
    room_name_column: str = "LongName",
    target_count_column: str = "Target Count",
    target_area_column: str = "Target Area/Room",
    output_path: Optional[str] = None,
    layout_config: Optional[ExcelLayoutConfig] = None
) -> pd.DataFrame:
    """
    Create a comparison between target room program and actual IFC spaces.
    
    Args:
        target_excel_path: Path to Excel file containing target room program
        ifc_loader: Instance of IfcLoader with loaded IFC model
        room_name_column: Column name in target Excel for room names (default: "Room Type")
        target_count_column: Column name for target room count (default: "Target Count")
        target_area_column: Column name for target room area (default: "Target Area")
        output_path: Optional path to save Excel report
        layout_config: Optional ExcelLayoutConfig for custom formatting
        
    Returns:
        pd.DataFrame: Comparison table with target vs actual metrics
    """
    # Load target room program
    try:
        target_df = pd.read_excel(target_excel_path)
        print(f"Loaded target Excel file. Columns found: {target_df.columns.tolist()}")  # Debug print
        
        # Verify required columns exist
        missing_columns = []
        for col, col_name in [
            (room_name_column, "room name"),
            (target_count_column, "target count"),
            (target_area_column, "target area")
        ]:
            if col not in target_df.columns:
                missing_columns.append(f"{col_name} ({col})")
        
        if missing_columns:
            raise ValueError(f"Missing required columns in target Excel: {', '.join(missing_columns)}")
            
    except Exception as e:
        print(f"Error loading target Excel file: {str(e)}")
        return pd.DataFrame()
        
    # Get actual spaces from IFC
    try:
        spaces_df = ifc_loader.get_space_information()
        print(f"Loaded spaces from IFC. Found {len(spaces_df)} spaces.")  # Debug print
        
        if spaces_df.empty:
            raise ValueError("No spaces found in IFC model")
            
        # Verify required IFC data columns
        if 'LongName' not in spaces_df.columns:
            raise ValueError("IFC spaces missing 'LongName' attribute")
        if 'Qto_SpaceBaseQuantities.NetFloorArea' not in spaces_df.columns:
            raise ValueError("IFC spaces missing 'NetFloorArea' quantity")
            
    except Exception as e:
        print(f"Error processing IFC spaces: {str(e)}")
        return pd.DataFrame()
    
    # Initialize result DataFrame
    result = pd.DataFrame()
    
    try:
        # Process each room type from target program
        data = []
        for _, row in target_df.iterrows():
            room_name = row[room_name_column]
            target_count = float(row[target_count_column])  # Convert to float for safety
            target_area = float(row[target_area_column])
            
            print(f"Processing room type: {room_name}")  # Debug print
            
            # Get actual spaces matching this room name
            actual_spaces = spaces_df[spaces_df['LongName'] == room_name]
            actual_count = len(actual_spaces)
            
            # Sum up actual areas
            actual_total_area = actual_spaces['Qto_SpaceBaseQuantities.NetFloorArea'].sum()
            
            print(f"Found {actual_count} spaces with total area {actual_total_area}")  # Debug print
            
            # Calculate metrics
            target_total_area = target_count * target_area
            avg_area_per_room = actual_total_area / actual_count if actual_count > 0 else 0
            
            count_diff = actual_count - target_count
            count_diff_pct = (count_diff / target_count * 100) if target_count > 0 else 0
            
            area_diff = actual_total_area - target_total_area
            area_diff_pct = (area_diff / target_total_area * 100) if target_total_area > 0 else 0
            
            data.append({
                'Room Type': room_name,
                'Target Count': target_count,
                'Target sqm/room': target_area,
                'Target Total sqm': target_total_area,
                'Actual Count': actual_count,
                'Actual Total sqm': actual_total_area,
                'Avg sqm/room': avg_area_per_room,
                'Count Diff': count_diff,
                '% Count Diff': count_diff_pct,
                'Area Diff': area_diff,
                '% Area Diff': area_diff_pct
            })
            
        result = pd.DataFrame(data)
        
        if result.empty:
            print("No data was processed - empty result DataFrame")
            return pd.DataFrame()
            
        # Add totals row
        totals = {
            'Room Type': 'TOTAL',
            'Target Count': result['Target Count'].sum(),
            'Target Total sqm': result['Target Total sqm'].sum(),
            'Actual Count': result['Actual Count'].sum(),
            'Actual Total sqm': result['Actual Total sqm'].sum(),
            'Count Diff': result['Count Diff'].sum(),
            'Area Diff': result['Area Diff'].sum()
        }
        
        # Calculate weighted averages for percentages
        total_target_count = result['Target Count'].sum()
        total_target_area = result['Target Total sqm'].sum()
        
        if total_target_count > 0:
            totals['% Count Diff'] = (totals['Count Diff'] / total_target_count * 100)
        if total_target_area > 0:
            totals['% Area Diff'] = (totals['Area Diff'] / total_target_area * 100)
            
        # Calculate overall average sqm/room
        if totals['Actual Count'] > 0:
            totals['Avg sqm/room'] = totals['Actual Total sqm'] / totals['Actual Count']
        else:
            totals['Avg sqm/room'] = 0
            
        totals['Target sqm/room'] = totals['Target Total sqm'] / totals['Target Count'] if totals['Target Count'] > 0 else 0
        
        # Append totals row
        result = pd.concat([result, pd.DataFrame([totals])], ignore_index=True)
        
        # Export to Excel if output path is provided
        if output_path:
            result = export_room_program_comparison(
                df=result,
                output_path=output_path,
                layout_config=layout_config
            )
        
        return result
        
    except Exception as e:
        print(f"Error creating comparison: {str(e)}")
        import traceback
        traceback.print_exc()  # Print full stack trace
        return pd.DataFrame()

def export_room_program_comparison(
    df: pd.DataFrame,
    output_path: str,
    layout_config: Optional[ExcelLayoutConfig] = None
) -> pd.DataFrame:
    """
    Export room program comparison to Excel with formatting.
    
    Args:
        df (pd.DataFrame): Room program comparison DataFrame
        output_path (str): Full path where the Excel file should be saved
        layout_config (Optional[ExcelLayoutConfig]): Configuration for Excel layout.
            If None, default settings will be used.
            
    Returns:
        pd.DataFrame: The exported DataFrame
    """
    if df.empty:
        print("Warning: Input DataFrame is empty!")
        return df
        
    # Make sure the output directory exists
    output_dir = os.path.dirname(output_path)
    if output_dir:  # Only create directory if path contains a directory component
        os.makedirs(output_dir, exist_ok=True)
        
    try:
        # Use provided config or create default one
        config = layout_config or ExcelLayoutConfig(
            horizontal_lines=True,
            vertical_lines=True,
            bold_headers=True,
            auto_column_width=True,
            alternating_colors=True,
            number_format='#,##0.00'
        )
        
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            df.to_excel(writer, index=False, sheet_name='Room Program Comparison')
            worksheet = writer.sheets['Room Program Comparison']
            
            # Auto-adjust column widths
            if config.auto_column_width:
                for idx, col in enumerate(df.columns):
                    max_length = max(
                        df[col].astype(str).apply(len).max(),
                        len(str(col))
                    )
                    adjusted_width = max_length + 2
                    column_letter = get_column_letter(idx + 1)
                    worksheet.column_dimensions[column_letter].width = adjusted_width
            
            # Set row height if specified
            if config.row_height:
                for row in range(1, len(df) + 2):
                    worksheet.row_dimensions[row].height = config.row_height
            
            # Format cells
            for row in range(1, len(df) + 2):
                for col in range(1, len(df.columns) + 1):
                    cell = worksheet.cell(row=row, column=col)
                    
                    # Add borders based on config
                    borders = {}
                    if config.horizontal_lines:
                        borders['bottom'] = openpyxl.styles.Side(style='thin')
                    if config.vertical_lines:
                        borders['right'] = openpyxl.styles.Side(style='thin')
                    if borders:
                        cell.border = openpyxl.styles.Border(**borders)
                    
                    # Format numbers (skip first column - Room Type)
                    if row > 1 and col > 1:
                        try:
                            float(cell.value)  # Check if value is numeric
                            # Use percentage format for % columns
                            if df.columns[col-1].startswith('%'):
                                cell.number_format = '0.00%'
                            else:
                                cell.number_format = config.number_format
                        except (TypeError, ValueError):
                            pass
                    
                    # Format headers
                    if row == 1 and config.bold_headers:
                        cell.font = openpyxl.styles.Font(bold=True)
                        if config.header_color:
                            cell.fill = openpyxl.styles.PatternFill(
                                start_color=config.header_color,
                                end_color=config.header_color,
                                fill_type='solid'
                            )
                    
                    # Format totals row (last row)
                    if row == len(df) + 1:
                        cell.font = openpyxl.styles.Font(bold=True)
                        cell.fill = openpyxl.styles.PatternFill(
                            start_color=config.header_color,
                            end_color=config.header_color,
                            fill_type='solid'
                        )
                    
                    # Apply alternating colors
                    elif config.alternating_colors and row > 1 and row <= len(df):
                        if row % 2 == 0:  # Even rows
                            cell.fill = openpyxl.styles.PatternFill(
                                start_color='F5F5F5',  # Light gray
                                end_color='F5F5F5',
                                fill_type='solid'
                            )

        print(f"Excel file successfully created at: {output_path}")
    except Exception as e:
        print(f"Error creating Excel file: {str(e)}")
        raise
        
    return df

def convert_html_to_pdf(
    html_content: str, 
    output_path: str,
    style_config: Optional[ReportStyleConfig] = None
) -> str:
    """
    Convert HTML content to PDF using WeasyPrint with styling.
    
    Args:
        html_content (str): HTML content to convert
        output_path (str): Path where the PDF should be saved
        style_config (Optional[ReportStyleConfig]): Configuration for report styling
        
    Returns:
        str: Path to the generated PDF file
        
    Raises:
        Exception: If PDF conversion fails
    """
    try:
        # Use default config if none provided
        style_config = style_config or ReportStyleConfig()
        
        # Add CSS to HTML content
        css = style_config.to_css()
        html_with_css = f"""
            <style>
                {css}
            </style>
            {html_content}
        """
        
        HTML(string=html_with_css).write_pdf(output_path)
        return output_path
    except Exception as e:
        raise Exception(f"Failed to convert HTML to PDF: {str(e)}")

def load_metrics_config() -> dict:
    """
    Load metrics configuration from YAML file.
    
    Returns:
        dict: Configuration dictionary
    """
    # Get the workspace root directory (two levels up from the current file)
    workspace_root = Path(__file__).parent.parent.parent
    config_path = workspace_root / 'src' / 'qto_buccaneer' / 'configs' / 'abstractBIM_report_config.yaml'
    print(f"Loading metrics config from: {config_path}")  # Debug print
    if not config_path.exists():
        raise FileNotFoundError(f"Metrics configuration file not found at: {config_path}")
    
    with open(config_path, 'r') as f:
        config = yaml.safe_load(f)
        print(f"Loaded config sections: {list(config.keys())}")  # Debug print
        return config

def build_metrics_table(
    metrics_df: pd.DataFrame, 
    base_metrics: dict = None,
    include_metrics: list = None,
    language: str = None
) -> dict:
    """
    Build a formatted metrics table from a DataFrame of metrics.
    
    Args:
        metrics_df (pd.DataFrame): DataFrame containing metrics with columns:
            - metric_name: Name of the metric
            - value: Numeric value
            - unit: Unit of measurement
        base_metrics (dict): Dictionary mapping metric names to their base metrics for percentages.
            If None, will use base_metrics from config.
        include_metrics (list): List of metric names to include in the table.
            If None, will use metrics defined in sections from config.
        language (str): Language code to use for display names (e.g., 'en', 'de').
            If None, will use default_language from config.
            
    Returns:
        dict: Dictionary containing sections with their metrics
    """
    print(f"Input metrics_df shape: {metrics_df.shape}")  # Debug print
    print(f"Input metrics_df columns: {metrics_df.columns.tolist()}")  # Debug print
    
    # Load configuration
    config = load_metrics_config()
    
    # Use default language if none specified
    if language is None:
        language = config.get('default_language', 'en')
    print(f"Using language: {language}")  # Debug print
    
    # Get all defined metrics from the configuration
    defined_metrics = set()
    for section in config.get('sections', []):
        if 'metrics' in section:
            defined_metrics.update(section.get('metrics', []))
    
    print(f"Defined metrics in config: {defined_metrics}")  # Debug print
    
    # First filter to only include metrics that exist in the DataFrame
    available_metrics = set(metrics_df['metric_name'].unique())
    print(f"Available metrics in DataFrame: {available_metrics}")  # Debug print
    
    # Determine which metrics to include
    if include_metrics and len(include_metrics) > 0:
        print(f"Using provided include_metrics: {include_metrics}")  # Debug print
        # Convert include_metrics to set for faster lookups
        include_metrics_set = set(include_metrics)
        # Only keep metrics that are both in include_metrics and available_metrics
        filtered_metrics = include_metrics_set.intersection(available_metrics)
        print(f"Metrics after include_metrics filter: {filtered_metrics}")  # Debug print
    else:
        # If no include_metrics provided or empty list, use defined metrics that are available
        filtered_metrics = defined_metrics.intersection(available_metrics)
        print(f"No include_metrics provided, using defined metrics: {filtered_metrics}")  # Debug print
    
    # Filter the DataFrame to only include the filtered metrics
    metrics_df = metrics_df[metrics_df['metric_name'].isin(filtered_metrics)].copy()
    print(f"Final DataFrame shape after filtering: {metrics_df.shape}")  # Debug print
    
    # Use provided base_metrics or load from config
    if base_metrics is None:
        base_metrics = {}
        for metric_id, metric_config in config.get('metrics', {}).items():
            if metric_config.get('base_metric'):
                base_metrics[metric_id] = metric_config['base_metric']
    
    # Get base metric values
    base_values = {}
    for base_metric in set(base_metrics.values()):
        try:
            base_values[base_metric] = metrics_df[metrics_df['metric_name'] == base_metric]['value'].iloc[0]
        except IndexError:
            base_values[base_metric] = 0
    
    # Build metrics table by sections
    result = {}
    for section in config.get('sections', []):
        section_id = section['id']
        section_title = section['title'].get(language, section['title']['en'])
        
        # Handle special sections
        if section_id == 'title_page':
            result[section_id] = {
                'title': section_title,
                'metrics': []  # No metrics for title page
            }
            continue
            
        if section_id == 'table_of_contents':
            result[section_id] = {
                'title': section_title,
                'metrics': []  # No metrics for table of contents
            }
            continue
            
        # Handle metrics sections
        section_metrics = []
        for metric_id in section.get('metrics', []):
            if metric_id not in filtered_metrics:
                continue
                
            metric_config = config['metrics'].get(metric_id, {})
            metric_row = metrics_df[metrics_df['metric_name'] == metric_id].iloc[0]
            
            # Get display name in selected language
            display_name = metric_config['name'].get(language, metric_config['name']['en'])
            
            # Format the value with unit - show just the number for count metrics
            value = metric_row['value']
            unit = metric_row['unit']
            if unit == 'count':
                formatted_value = f"{value}"
            else:
                formatted_value = f"{value:.2f} {unit}"
            
            # Calculate and format percentage if applicable
            percentage = ''
            base_metric = metric_config.get('base_metric')
            if base_metric:
                base_value = base_values.get(base_metric, 0)
                if base_value > 0:
                    pct = (value / base_value) * 100
                    base_name = config['metrics'][base_metric]['name'].get(language, config['metrics'][base_metric]['name']['en'])
                    percentage = config['formatting']['percentage']['format'].format(
                        value=pct,
                        base_name=base_name.split('(')[0].strip(),
                        of_word=config['formatting']['percentage']['languages'].get(language, 'of')
                    )
            
            section_metrics.append({
                'name': display_name,
                'value1': formatted_value,
                'value2': percentage
            })
        
        if section_metrics:  # Only add section if it has metrics
            result[section_id] = {
                'title': section_title,
                'metrics': section_metrics
            }
    
    print(f"Final sections: {list(result.keys())}")  # Debug print
    return result

def generate_metrics_report(
    metrics_df: pd.DataFrame,
    building_name: str,
    plots_dir: str,
    building_adresse: Optional[str] = None,
    building_description: Optional[str] = None,
    output_dir: str = 'reports',
    template_path: str = 'configs/abstractBIM_report_template.html',
    style_config: Optional[ReportStyleConfig] = None,
    report_config_path: str = "abstractBIM_report_config.yaml"
) -> str:
    """
    Generate a metrics report from the provided metrics DataFrame.
    
    Args:
        metrics_df (pd.DataFrame): DataFrame containing the metrics data
        building_name (str): Name of the project, used for the report title
        plots_dir (str): Directory containing report plots
        building_adresse (Optional[str]): Address of the building
        building_description (Optional[str]): Description of the building
        output_dir (str): Directory where the final PDF report will be saved
        template_path (str): Path to the report template HTML file
        style_config (Optional[ReportStyleConfig]): Configuration for report styling
        report_config_path (str): Path to the report configuration YAML file
        
    Returns:
        str: Path to the generated PDF report
    """
    # Get the workspace root directory (two levels up from the current file)
    workspace_root = Path(__file__).parent.parent.parent
    
    # Convert relative paths to absolute paths
    template_file = str(workspace_root / 'src' / 'qto_buccaneer' / template_path)
    plots_dir = str(workspace_root / plots_dir)
    output_dir = str(workspace_root / output_dir)
    
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Construct output file path
    output_file = f"{building_name}_report.pdf"
    output_path = os.path.join(output_dir, output_file)
    
    print(f"Looking for template at: {template_file}")  # Debug print
    
    # Set default image placeholders and formats
    image_placeholders = ['pic_gfa', 'pic_gv', 'pic_project', 'pic_room_floorplan_scale']
    image_formats = ['.png', '.jpg', '.jpeg']
    
    # Collect available images
    images = {}
    for key in image_placeholders:
        found = False
        for ext in image_formats:
            img_path = os.path.join(plots_dir, f"{key}{ext}")
            if os.path.isfile(img_path):
                images[key] = img_path
                found = True
                break
        if not found:
            images[key] = None
    
    # Verify template file exists
    if not os.path.isfile(template_file):
        raise FileNotFoundError(f"Template file not found: {template_file}")
    
    # Load report configuration if provided
    include_metrics = None
    if report_config_path:
        try:
            with open(report_config_path, 'r') as f:
                report_config = yaml.safe_load(f)
                include_metrics = report_config.get('include_metrics', [])
                print(f"Loaded include_metrics from config: {include_metrics}")  # Debug print
        except Exception as e:
            print(f"Warning: Could not load report config: {e}")
    
    # Create metrics table using the build_metrics_table function
    metrics_table = build_metrics_table(metrics_df, include_metrics=include_metrics)
    
    # Render HTML
    template_dir = os.path.dirname(template_file)
    template_name = os.path.basename(template_file)
    env = Environment(loader=FileSystemLoader(template_dir))
    template = env.get_template(template_name)
    
    html_out = template.render(
        project_name=building_name,
        file_name=building_name,
        address=building_adresse or "",
        description=building_description or "",
        date_time=datetime.now().strftime('%Y-%m-%d %H:%M'),
        images=images,
        logo_path=style_config.logo_path if style_config else None,
        metrics_table=metrics_table  # Pass the metrics table to the template
    )
    
    # Save HTML
    html_path = output_path.replace('.pdf', '.html')
    with open(html_path, 'w') as f:
        f.write(html_out)
    
    # Convert to PDF with styling
    try:
        convert_html_to_pdf(html_out, output_path, style_config)
    except Exception as e:
        print(f"Warning: Could not convert to PDF: {e}")
        print(f"HTML report saved at: {html_path}")
        return html_path
    
    return output_path

def fill_text_line(text: str, width: int = 80, fill_char: str = " ") -> str:
    """
    Fill a text line to a specific width with a fill character.
    
    Args:
        text (str): The text to fill
        width (int): The total width of the line
        fill_char (str): The character to use for filling
        
    Returns:
        str: The filled text line
    """
    if not text:
        return fill_char * width
        
    # Split text into words
    words = text.split()
    if not words:
        return fill_char * width
        
    # Start with the first word
    lines = [words[0]]
    current_length = len(words[0])
    
    # Add remaining words
    for word in words[1:]:
        # If adding the word would exceed the width, start a new line
        if current_length + len(word) + 1 > width:
            lines.append(word)
            current_length = len(word)
        else:
            # Add the word to the current line
            lines[-1] += " " + word
            current_length += len(word) + 1
            
    # Fill each line to the specified width
    filled_lines = []
    for line in lines:
        # Calculate how many fill characters to add
        fill_count = width - len(line)
        if fill_count > 0:
            filled_line = line + (fill_char * fill_count)
        else:
            filled_line = line
        filled_lines.append(filled_line)
        
    return "\n".join(filled_lines)

def format_definition_line(term: str, definition: str, width: int = 80) -> str:
    """
    Format a definition line with the term and definition.
    
    Args:
        term (str): The term being defined
        definition (str): The definition of the term
        width (int): The total width of the line
        
    Returns:
        str: The formatted definition line
    """
    # Create the line with term and definition
    line = f"{term}: {definition}"
    return fill_text_line(line, width)

def format_disclaimer(disclaimer: str, width: int = 80) -> str:
    """
    Format the disclaimer text.
    
    Args:
        disclaimer (str): The disclaimer text
        width (int): The total width of the line
        
    Returns:
        str: The formatted disclaimer
    """
    return fill_text_line(disclaimer, width)

# Example usage in the template rendering:
def render_template_with_filled_text(template, context):
    """
    Render the template with filled text lines.
    
    Args:
        template: The Jinja2 template
        context (dict): The context for the template
        
    Returns:
        str: The rendered template with filled text
    """
    # Format definitions
    definitions = [
        ("Gross Floor Area (GFA)", "The total area of all floors in a building, measured from the exterior walls."),
        ("Gross Volume (GV)", "The total volume of the building, including all enclosed spaces."),
        ("Net Floor Area (NFA)", "The usable area within the building, excluding walls."),
        ("Net Volume (NV)", "The volume of usable space within the building."),
        ("Construction Area", "Difference between GFA and NFA."),
        ("Construction Volume", "Difference between GV and NV."),
        ("Facade Area (FA)", "The total exterior surface area of the building envelope."),
        ("Room Type", "A classification of rooms based on their intended function."),
        ("Spatial Relationships", "Position between elements (e.g., a window relating to a room)."),
        ("Storey", "A horizontal division of a building."),
        ("Baseplate", "The foundational slab at the bottom of the building."),
        ("Covering Area", "Area of facade elements like cladding and panels.")
    ]
    
    # Format each definition
    formatted_definitions = [
        format_definition_line(term, definition)
        for term, definition in definitions
    ]
    
    # Format disclaimer
    disclaimer = "These quantities were generated automatically using the abstractBIM system. Accuracy depends on input quality. The general terms and conditions of abstract AG apply."
    formatted_disclaimer = format_disclaimer(disclaimer)
    
    # Add formatted text to context
    context.update({
        'formatted_definitions': formatted_definitions,
        'formatted_disclaimer': formatted_disclaimer
    })
    
    return template.render(context)

