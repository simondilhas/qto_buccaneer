<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>qto_buccaneer.utils.ifc_json_loader API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qto_buccaneer.utils.ifc_json_loader</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader"><code class="flex name class">
<span>class <span class="ident">IfcJsonLoader</span></span>
<span>(</span><span>json_paths: str | pathlib.Path | List[str | pathlib.Path] | None = None,<br>properties_json: dict | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IfcJsonLoader:
    &#34;&#34;&#34;A class to load and manage IFC data from JSON files or pre-loaded JSON data.
    
    This class provides methods to access geometry and properties data from IFC models
    that have been converted to JSON format. It can handle multiple geometry files or
    pre-loaded JSON data.
    &#34;&#34;&#34;

    # TODO:get_elements_by_type should be the template for the other methods return a pd.DataFrame
    
    def __init__(self, 
                 json_paths: Optional[Union[str, Path, List[Union[str, Path]]]] = None,
                 properties_json: Optional[dict] = None):
        &#34;&#34;&#34;
        Initialize the loader.
        
        Args:
            json_paths: Optional path or list of paths to IFC JSON files
            properties_json: Optional pre-loaded properties JSON data
        &#34;&#34;&#34;
        if json_paths is not None:
            # Convert single path to list
            if isinstance(json_paths, (str, Path)):
                json_paths = [json_paths]
                
            self.json_paths = [Path(p) for p in json_paths]
            self.data = self._load_jsons()
        elif properties_json is not None:
            self.json_paths = None
            self.data = properties_json
        else:
            raise ValueError(&#34;Either json_paths or properties_json must be provided&#34;)
            
        self.elements = self._process_elements()
        self._geometry_loaded = False
        
    def add_geometry_files(self, json_paths: Union[str, Path, List[Union[str, Path]]]) -&gt; None:
        &#34;&#34;&#34;Add additional geometry files to the loader.
        
        Args:
            json_paths: Path or list of paths to additional IFC JSON files
        &#34;&#34;&#34;
        if self.json_paths is None:
            raise ValueError(&#34;Cannot add geometry files when initialized with properties_json&#34;)
            
        # Convert single path to list
        if isinstance(json_paths, (str, Path)):
            json_paths = [json_paths]
            
        new_paths = [Path(p) for p in json_paths]
        self.json_paths.extend(new_paths)
        
        # Load new data
        new_data = self._load_jsons_from_paths(new_paths)
        
        # Update existing data
        if isinstance(self.data, list):
            self.data.extend(new_data)
        else:
            self.data = [self.data] + new_data
            
        # Reprocess elements to include new geometry
        self.elements = self._process_elements()
        self._geometry_loaded = False
        
    def _load_jsons_from_paths(self, paths: List[Path]) -&gt; List[dict]:
        &#34;&#34;&#34;Load JSON files from specific paths.&#34;&#34;&#34;
        all_data = []
        for path in paths:
            with open(path, &#39;r&#39;) as f:
                all_data.extend(json.load(f))
        return all_data
        
    def _load_jsons(self) -&gt; List[dict]:
        &#34;&#34;&#34;Load all JSON files.&#34;&#34;&#34;
        return self._load_jsons_from_paths(self.json_paths)
            
    def _process_elements(self) -&gt; Dict[str, dict]:
        &#34;&#34;&#34;Process elements from all JSON data.&#34;&#34;&#34;
        elements = {}
        
        # Handle both list and dict input
        data_list = self.data if isinstance(self.data, list) else [self.data]
        
        for element in data_list:
            element_id = element.get(&#39;ifc_global_id&#39;)
            if not element_id:
                continue
                
            # Basic properties
            element_data = {
                &#39;id&#39;: element.get(&#39;id&#39;),
                &#39;type&#39;: element.get(&#39;ifc_type&#39;),
                &#39;vertices&#39;: np.array(element.get(&#39;vertices&#39;, [])),
                &#39;faces&#39;: np.array(element.get(&#39;faces&#39;, []))
            }
                
            # If element already exists, merge geometry data
            if element_id in elements:
                existing = elements[element_id]
                # Combine vertices and faces
                existing[&#39;vertices&#39;] = np.vstack((existing[&#39;vertices&#39;], element_data[&#39;vertices&#39;]))
                existing[&#39;faces&#39;] = np.vstack((existing[&#39;faces&#39;], element_data[&#39;faces&#39;]))
            else:
                elements[element_id] = element_data
            
        return elements
        
    def load_geometry(self) -&gt; None:
        &#34;&#34;&#34;Load geometry data for all elements from all files.&#34;&#34;&#34;
        if self._geometry_loaded:
            return
            
        # Handle both list and dict input
        data_list = self.data if isinstance(self.data, list) else [self.data]
            
        for element in data_list:
            element_id = element.get(&#39;ifc_global_id&#39;)
            if not element_id:
                continue
                
            geometry = self._extract_geometry(element)
            if geometry:
                if &#39;geometry&#39; not in self.elements[element_id]:
                    self.elements[element_id][&#39;geometry&#39;] = geometry
                else:
                    # Merge geometry data
                    existing = self.elements[element_id][&#39;geometry&#39;]
                    existing[&#39;vertices&#39;] = np.vstack((existing[&#39;vertices&#39;], geometry[&#39;vertices&#39;]))
                    existing[&#39;faces&#39;] = np.vstack((existing[&#39;faces&#39;], geometry[&#39;faces&#39;]))
                
        self._geometry_loaded = True
        
    def load_geometry_for_element(self, element_id: str) -&gt; None:
        &#34;&#34;&#34;Load geometry data for a specific element from all files.&#34;&#34;&#34;
        if element_id not in self.elements:
            return
            
        # Handle both list and dict input
        data_list = self.data if isinstance(self.data, list) else [self.data]
            
        elements = [
            e for e in data_list 
            if e.get(&#39;ifc_global_id&#39;) == element_id
        ]
        
        for element in elements:
            geometry = self._extract_geometry(element)
            if geometry:
                if &#39;geometry&#39; not in self.elements[element_id]:
                    self.elements[element_id][&#39;geometry&#39;] = geometry
                else:
                    # Merge geometry data
                    existing = self.elements[element_id][&#39;geometry&#39;]
                    existing[&#39;vertices&#39;] = np.vstack((existing[&#39;vertices&#39;], geometry[&#39;vertices&#39;]))
                    existing[&#39;faces&#39;] = np.vstack((existing[&#39;faces&#39;], geometry[&#39;faces&#39;]))
                
    def _extract_geometry(self, element: dict) -&gt; Optional[dict]:
        &#34;&#34;&#34;Extract geometry data from an element.&#34;&#34;&#34;
        vertices = element.get(&#39;vertices&#39;)
        faces = element.get(&#39;faces&#39;)
        if not vertices or not faces:
            return None
            
        return {
            &#39;vertices&#39;: np.array(vertices),
            &#39;faces&#39;: np.array(faces)
        }
        
    def get_element(self, global_id: str, load_geometry: bool = False) -&gt; Optional[dict]:
        &#34;&#34;&#34;Get an element by its GlobalId.
        
        Args:
            global_id: The GlobalId of the element
            load_geometry: Whether to load geometry data if not already loaded
        &#34;&#34;&#34;
        if load_geometry and not self._geometry_loaded:
            self.load_geometry_for_element(global_id)
            
        return self.elements.get(global_id)
        
    def get_elements_by_type(self, ifc_entity: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Get all element IDs for a given IFC entity type.
        
        Args:
            ifc_entity: The IFC entity type to filter by (e.g., &#34;IfcSpace&#34;)
            
        Returns:
            DataFrame containing element IDs and their metadata
        &#34;&#34;&#34;
        elements_data = []
        
        # Handle both list and dict input
        data_list = self.data if isinstance(self.data, list) else [self.data]
        
        for data in data_list:
            # Get elements from the nested structure
            elements = data.get(&#39;elements&#39;, {})
            
            for element_id, element in elements.items():
                if element.get(&#39;IfcEntity&#39;) == ifc_entity:
                    # Create a dictionary with all available data
                    element_data = {}
                    
                    # Add all fields from the element except geometry data
                    for key, value in element.items():
                        # Skip geometry-related fields
                        if key in [&#39;vertices&#39;, &#39;faces&#39;, &#39;geometry&#39;]:
                            continue
                            
                        # Handle nested properties
                        if isinstance(value, dict):
                            # Special handling for Qto_SpaceBaseQuantities
                            if key == &#39;Qto_SpaceBaseQuantities&#39;:
                                for nested_key, nested_value in value.items():
                                    new_key = f&#34;{key}.{nested_key}&#34;
                                    element_data[new_key] = nested_value
                            else:
                                for nested_key, nested_value in value.items():
                                    new_key = f&#34;{key}.{nested_key}&#34;
                                    element_data[new_key] = nested_value
                        else:
                            element_data[key] = value
                    
                    # Find storey by traversing up the parent chain
                    current_id = element.get(&#39;parent_id&#39;)
                    storey_name = &#39;Unknown&#39;
                    
                    while current_id is not None:
                        current = elements.get(str(current_id))
                        if not current:
                            break
                            
                        if current.get(&#39;IfcEntity&#39;) == &#39;IfcBuildingStorey&#39;:
                            storey_name = current.get(&#39;Name&#39;, &#39;Unknown&#39;)
                            break
                            
                        current_id = current.get(&#39;parent_id&#39;)
                    
                    element_data[&#39;BuildingStorey&#39;] = storey_name
                    elements_data.append(element_data)
        
        df = pd.DataFrame(elements_data)
        print(&#34;\n=== DataFrame Columns ===&#34;)
        print(f&#34;Available columns: {df.columns.tolist()}&#34;)
        return df
        
    def get_elements_with_property(self, property_name: str, value: Union[str, float, int], load_geometry: bool = False) -&gt; List[dict]:
        &#34;&#34;&#34;Get elements with a specific property value.
        
        Args:
            property_name: The name of the property to check
            value: The value to match
            load_geometry: Whether to load geometry data if not already loaded
        &#34;&#34;&#34;
        if load_geometry and not self._geometry_loaded:
            self.load_geometry()
            
        return [
            element for element in self.elements.values()
            if element[&#39;properties&#39;].get(property_name) == value
        ]
        
    def get_elements_with_quantity(self, quantity_name: str, min_value: float = None, max_value: float = None, load_geometry: bool = False) -&gt; List[dict]:
        &#34;&#34;&#34;Get elements with a quantity within a range.
        
        Args:
            quantity_name: The name of the quantity to check
            min_value: Minimum value (inclusive)
            max_value: Maximum value (inclusive)
            load_geometry: Whether to load geometry data if not already loaded
        &#34;&#34;&#34;
        if load_geometry and not self._geometry_loaded:
            self.load_geometry()
            
        elements = []
        for element in self.elements.values():
            quantity = element[&#39;quantities&#39;].get(quantity_name)
            if quantity is None:
                continue
                
            if min_value is not None and quantity &lt; min_value:
                continue
            if max_value is not None and quantity &gt; max_value:
                continue
                
            elements.append(element)
            
        return elements

    def _build_storey_cache(self):
        &#34;&#34;&#34;Build a cache of element_id -&gt; storey_name mappings.&#34;&#34;&#34;
        # First build storey name lookup
        storey_names = {}
        for storey_id in self.by_type_index.get(&#39;IfcBuildingStorey&#39;, []):
            storey = self.properties_index.get(str(storey_id))
            if storey:
                storey_names[str(storey_id)] = storey.get(&#39;Name&#39;, &#39;Unknown&#39;)
        
        print(f&#34;\n=== Building Storey Cache ===&#34;)
        print(f&#34;Found {len(storey_names)} storeys with names:&#34;)
        for storey_id, name in storey_names.items():
            print(f&#34;  - Storey {storey_id}: {name}&#34;)
            storey = self.properties_index.get(str(storey_id))
            print(f&#34;    Full storey data: {storey}&#34;)
        
        print(&#34;\n=== Building Element -&gt; Storey Mapping ===&#34;)
        # First map elements directly contained in storeys
        for storey_id, storey_name in storey_names.items():
            storey = self.properties_index.get(str(storey_id))
            if not storey:
                continue
                
            # Get elements directly contained in this storey
            contained_elements = storey.get(&#39;ContainsElements&#39;, [])
            if isinstance(contained_elements, str):
                # Handle case where it&#39;s a string representation of a list
                contained_elements = [e.strip(&#34;&#39;&#34;) for e in contained_elements.strip(&#39;[]&#39;).split(&#39;,&#39;)]
            
            print(f&#34;\nStorey {storey_name} contains elements:&#34;)
            for element_id in contained_elements:
                if element_id:
                    self._storey_cache[str(element_id)] = storey_name
                    element = self.properties_index.get(str(element_id))
                    print(f&#34;  - Element {element_id}:&#34;)
                    print(f&#34;    Type: {element.get(&#39;IfcEntity&#39;, &#39;Unknown&#39;) if element else &#39;Unknown&#39;}&#34;)
                    print(f&#34;    Properties: {element}&#34;)
        
        # Then handle elements that might be nested under other elements
        for element_id, element in self.properties_index.items():
            if element_id in self._storey_cache:
                continue
                
            current_id = str(element_id)
            path = []
            while current_id:
                path.append(current_id)
                if current_id in storey_names:
                    self._storey_cache[str(element_id)] = storey_names[current_id]
                    print(f&#34;\nElement {element_id}:&#34;)
                    print(f&#34;  Type: {element.get(&#39;IfcEntity&#39;, &#39;Unknown&#39;)}&#34;)
                    print(f&#34;  Parent chain: {&#39; -&gt; &#39;.join(path)}&#34;)
                    print(f&#34;  Assigned to storey: {storey_names[current_id]}&#34;)
                    break
                current = self.properties_index.get(str(current_id))
                if not current:
                    print(f&#34;\nElement {element_id}:&#34;)
                    print(f&#34;  Type: {element.get(&#39;IfcEntity&#39;, &#39;Unknown&#39;)}&#34;)
                    print(f&#34;  Parent chain: {&#39; -&gt; &#39;.join(path)}&#34;)
                    print(f&#34;  WARNING: Parent chain broken at {current_id}&#34;)
                    break
                # Convert parent_id to string if it exists
                parent_id = current.get(&#39;parent_id&#39;)
                current_id = str(parent_id) if parent_id is not None else None
                if not current_id:
                    print(f&#34;\nElement {element_id}:&#34;)
                    print(f&#34;  Type: {element.get(&#39;IfcEntity&#39;, &#39;Unknown&#39;)}&#34;)
                    print(f&#34;  Parent chain: {&#39; -&gt; &#39;.join(path)}&#34;)
                    print(f&#34;  WARNING: No parent_id found for {current_id}&#34;)
        
        print(f&#34;\n=== Summary ===&#34;)
        print(f&#34;Built storey cache with {len(self._storey_cache)} elements&#34;)
        print(f&#34;Elements without storey: {len(self.properties_index) - len(self._storey_cache)}&#34;)
        
        # Print space-specific summary
        spaces = [id for id, elem in self.properties_index.items() if elem.get(&#39;IfcEntity&#39;) == &#39;IfcSpace&#39;]
        spaces_with_storey = [id for id in spaces if id in self._storey_cache]
        print(f&#34;\n=== Spaces Summary ===&#34;)
        print(f&#34;Total spaces: {len(spaces)}&#34;)
        print(f&#34;Spaces with storey: {len(spaces_with_storey)}&#34;)
        print(f&#34;Spaces without storey: {len(spaces) - len(spaces_with_storey)}&#34;)
        for space_id in spaces:
            storey = self._storey_cache.get(str(space_id))
            print(f&#34;\nSpace {space_id}:&#34;)
            print(f&#34;  Storey: {storey if storey else &#39;Not found&#39;}&#34;)
            space = self.properties_index.get(str(space_id))
            print(f&#34;  Parent ID: {space.get(&#39;parent_id&#39;, &#39;None&#39;)}&#34;)
            print(f&#34;  Properties: {space}&#34;)
    
    def get_spaces_in_storey(self, storey_name: str) -&gt; List[str]:
        &#34;&#34;&#34;Return a list of IDs of spaces in a given storey.
        
        Args:
            storey_name: Name of the storey to filter spaces by
            
        Returns:
            List of IDs for spaces in the specified storey
        &#34;&#34;&#34;
        ids = []
        # Get all spaces using the by_type index
        space_ids = self.by_type_index.get(&#34;IfcSpace&#34;, [])
        
        for space_id in space_ids:
            space = self.properties_index.get(str(space_id))
            if not space:
                continue
                
            # Get storey from cache
            space_storey = self._storey_cache.get(str(space_id))
            
            # If no storey info, include the space in all storeys
            if space_storey is None:
                ids.append(str(space_id))
                print(f&#34;Found space {space_id} (no storey info)&#34;)
            # Otherwise check if the storey name matches
            elif space_storey == storey_name:
                ids.append(str(space_id))
                print(f&#34;Found space {space_id} in storey {storey_name}&#34;)
        
        return ids
    
    def get_geometry(self, element_id: str) -&gt; Optional[Dict[str, Any]]:
        &#34;&#34;&#34;Get geometry for a given element ID.
        
        Args:
            element_id: The ID of the element to get geometry for
            
        Returns:
            Geometry data for the element, or None if not found
        &#34;&#34;&#34;
        return self.geometry_index.get(str(element_id))
    
    def get_properties(self, element_id: str) -&gt; Optional[Dict[str, Any]]:
        &#34;&#34;&#34;Get properties for a given element ID.
        
        Args:
            element_id: The ID of the element to get properties for
            
        Returns:
            Properties data for the element, or None if not found
        &#34;&#34;&#34;
        return self.properties_index.get(str(element_id))
    
    def get_storey_for_space(self, space_id: str) -&gt; Optional[str]:
        &#34;&#34;&#34;Get the storey name for a given space.
        
        Args:
            space_id: The ID of the space
            
        Returns:
            The storey name, or None if not found
        &#34;&#34;&#34;
        return self._storey_cache.get(str(space_id))

    def get_storey_for_element(self, element_id: str) -&gt; Optional[str]:
        &#34;&#34;&#34;Get the storey name for an element by its ID.&#34;&#34;&#34;
        return self._storey_cache.get(str(element_id))</code></pre>
</details>
<div class="desc"><p>A class to load and manage IFC data from JSON files or pre-loaded JSON data.</p>
<p>This class provides methods to access geometry and properties data from IFC models
that have been converted to JSON format. It can handle multiple geometry files or
pre-loaded JSON data.</p>
<p>Initialize the loader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>json_paths</code></strong></dt>
<dd>Optional path or list of paths to IFC JSON files</dd>
<dt><strong><code>properties_json</code></strong></dt>
<dd>Optional pre-loaded properties JSON data</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.add_geometry_files"><code class="name flex">
<span>def <span class="ident">add_geometry_files</span></span>(<span>self, json_paths: str | pathlib.Path | List[str | pathlib.Path]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_geometry_files(self, json_paths: Union[str, Path, List[Union[str, Path]]]) -&gt; None:
    &#34;&#34;&#34;Add additional geometry files to the loader.
    
    Args:
        json_paths: Path or list of paths to additional IFC JSON files
    &#34;&#34;&#34;
    if self.json_paths is None:
        raise ValueError(&#34;Cannot add geometry files when initialized with properties_json&#34;)
        
    # Convert single path to list
    if isinstance(json_paths, (str, Path)):
        json_paths = [json_paths]
        
    new_paths = [Path(p) for p in json_paths]
    self.json_paths.extend(new_paths)
    
    # Load new data
    new_data = self._load_jsons_from_paths(new_paths)
    
    # Update existing data
    if isinstance(self.data, list):
        self.data.extend(new_data)
    else:
        self.data = [self.data] + new_data
        
    # Reprocess elements to include new geometry
    self.elements = self._process_elements()
    self._geometry_loaded = False</code></pre>
</details>
<div class="desc"><p>Add additional geometry files to the loader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>json_paths</code></strong></dt>
<dd>Path or list of paths to additional IFC JSON files</dd>
</dl></div>
</dd>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, global_id: str, load_geometry: bool = False) ‑> dict | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, global_id: str, load_geometry: bool = False) -&gt; Optional[dict]:
    &#34;&#34;&#34;Get an element by its GlobalId.
    
    Args:
        global_id: The GlobalId of the element
        load_geometry: Whether to load geometry data if not already loaded
    &#34;&#34;&#34;
    if load_geometry and not self._geometry_loaded:
        self.load_geometry_for_element(global_id)
        
    return self.elements.get(global_id)</code></pre>
</details>
<div class="desc"><p>Get an element by its GlobalId.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>global_id</code></strong></dt>
<dd>The GlobalId of the element</dd>
<dt><strong><code>load_geometry</code></strong></dt>
<dd>Whether to load geometry data if not already loaded</dd>
</dl></div>
</dd>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_elements_by_type"><code class="name flex">
<span>def <span class="ident">get_elements_by_type</span></span>(<span>self, ifc_entity: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elements_by_type(self, ifc_entity: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Get all element IDs for a given IFC entity type.
    
    Args:
        ifc_entity: The IFC entity type to filter by (e.g., &#34;IfcSpace&#34;)
        
    Returns:
        DataFrame containing element IDs and their metadata
    &#34;&#34;&#34;
    elements_data = []
    
    # Handle both list and dict input
    data_list = self.data if isinstance(self.data, list) else [self.data]
    
    for data in data_list:
        # Get elements from the nested structure
        elements = data.get(&#39;elements&#39;, {})
        
        for element_id, element in elements.items():
            if element.get(&#39;IfcEntity&#39;) == ifc_entity:
                # Create a dictionary with all available data
                element_data = {}
                
                # Add all fields from the element except geometry data
                for key, value in element.items():
                    # Skip geometry-related fields
                    if key in [&#39;vertices&#39;, &#39;faces&#39;, &#39;geometry&#39;]:
                        continue
                        
                    # Handle nested properties
                    if isinstance(value, dict):
                        # Special handling for Qto_SpaceBaseQuantities
                        if key == &#39;Qto_SpaceBaseQuantities&#39;:
                            for nested_key, nested_value in value.items():
                                new_key = f&#34;{key}.{nested_key}&#34;
                                element_data[new_key] = nested_value
                        else:
                            for nested_key, nested_value in value.items():
                                new_key = f&#34;{key}.{nested_key}&#34;
                                element_data[new_key] = nested_value
                    else:
                        element_data[key] = value
                
                # Find storey by traversing up the parent chain
                current_id = element.get(&#39;parent_id&#39;)
                storey_name = &#39;Unknown&#39;
                
                while current_id is not None:
                    current = elements.get(str(current_id))
                    if not current:
                        break
                        
                    if current.get(&#39;IfcEntity&#39;) == &#39;IfcBuildingStorey&#39;:
                        storey_name = current.get(&#39;Name&#39;, &#39;Unknown&#39;)
                        break
                        
                    current_id = current.get(&#39;parent_id&#39;)
                
                element_data[&#39;BuildingStorey&#39;] = storey_name
                elements_data.append(element_data)
    
    df = pd.DataFrame(elements_data)
    print(&#34;\n=== DataFrame Columns ===&#34;)
    print(f&#34;Available columns: {df.columns.tolist()}&#34;)
    return df</code></pre>
</details>
<div class="desc"><p>Get all element IDs for a given IFC entity type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ifc_entity</code></strong></dt>
<dd>The IFC entity type to filter by (e.g., "IfcSpace")</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DataFrame containing element IDs and their metadata</p></div>
</dd>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_elements_with_property"><code class="name flex">
<span>def <span class="ident">get_elements_with_property</span></span>(<span>self, property_name: str, value: str | float | int, load_geometry: bool = False) ‑> List[dict]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elements_with_property(self, property_name: str, value: Union[str, float, int], load_geometry: bool = False) -&gt; List[dict]:
    &#34;&#34;&#34;Get elements with a specific property value.
    
    Args:
        property_name: The name of the property to check
        value: The value to match
        load_geometry: Whether to load geometry data if not already loaded
    &#34;&#34;&#34;
    if load_geometry and not self._geometry_loaded:
        self.load_geometry()
        
    return [
        element for element in self.elements.values()
        if element[&#39;properties&#39;].get(property_name) == value
    ]</code></pre>
</details>
<div class="desc"><p>Get elements with a specific property value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>property_name</code></strong></dt>
<dd>The name of the property to check</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The value to match</dd>
<dt><strong><code>load_geometry</code></strong></dt>
<dd>Whether to load geometry data if not already loaded</dd>
</dl></div>
</dd>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_elements_with_quantity"><code class="name flex">
<span>def <span class="ident">get_elements_with_quantity</span></span>(<span>self,<br>quantity_name: str,<br>min_value: float = None,<br>max_value: float = None,<br>load_geometry: bool = False) ‑> List[dict]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elements_with_quantity(self, quantity_name: str, min_value: float = None, max_value: float = None, load_geometry: bool = False) -&gt; List[dict]:
    &#34;&#34;&#34;Get elements with a quantity within a range.
    
    Args:
        quantity_name: The name of the quantity to check
        min_value: Minimum value (inclusive)
        max_value: Maximum value (inclusive)
        load_geometry: Whether to load geometry data if not already loaded
    &#34;&#34;&#34;
    if load_geometry and not self._geometry_loaded:
        self.load_geometry()
        
    elements = []
    for element in self.elements.values():
        quantity = element[&#39;quantities&#39;].get(quantity_name)
        if quantity is None:
            continue
            
        if min_value is not None and quantity &lt; min_value:
            continue
        if max_value is not None and quantity &gt; max_value:
            continue
            
        elements.append(element)
        
    return elements</code></pre>
</details>
<div class="desc"><p>Get elements with a quantity within a range.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>quantity_name</code></strong></dt>
<dd>The name of the quantity to check</dd>
<dt><strong><code>min_value</code></strong></dt>
<dd>Minimum value (inclusive)</dd>
<dt><strong><code>max_value</code></strong></dt>
<dd>Maximum value (inclusive)</dd>
<dt><strong><code>load_geometry</code></strong></dt>
<dd>Whether to load geometry data if not already loaded</dd>
</dl></div>
</dd>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_geometry"><code class="name flex">
<span>def <span class="ident">get_geometry</span></span>(<span>self, element_id: str) ‑> Dict[str, Any] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_geometry(self, element_id: str) -&gt; Optional[Dict[str, Any]]:
    &#34;&#34;&#34;Get geometry for a given element ID.
    
    Args:
        element_id: The ID of the element to get geometry for
        
    Returns:
        Geometry data for the element, or None if not found
    &#34;&#34;&#34;
    return self.geometry_index.get(str(element_id))</code></pre>
</details>
<div class="desc"><p>Get geometry for a given element ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>element_id</code></strong></dt>
<dd>The ID of the element to get geometry for</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Geometry data for the element, or None if not found</p></div>
</dd>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_properties"><code class="name flex">
<span>def <span class="ident">get_properties</span></span>(<span>self, element_id: str) ‑> Dict[str, Any] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_properties(self, element_id: str) -&gt; Optional[Dict[str, Any]]:
    &#34;&#34;&#34;Get properties for a given element ID.
    
    Args:
        element_id: The ID of the element to get properties for
        
    Returns:
        Properties data for the element, or None if not found
    &#34;&#34;&#34;
    return self.properties_index.get(str(element_id))</code></pre>
</details>
<div class="desc"><p>Get properties for a given element ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>element_id</code></strong></dt>
<dd>The ID of the element to get properties for</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Properties data for the element, or None if not found</p></div>
</dd>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_spaces_in_storey"><code class="name flex">
<span>def <span class="ident">get_spaces_in_storey</span></span>(<span>self, storey_name: str) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_spaces_in_storey(self, storey_name: str) -&gt; List[str]:
    &#34;&#34;&#34;Return a list of IDs of spaces in a given storey.
    
    Args:
        storey_name: Name of the storey to filter spaces by
        
    Returns:
        List of IDs for spaces in the specified storey
    &#34;&#34;&#34;
    ids = []
    # Get all spaces using the by_type index
    space_ids = self.by_type_index.get(&#34;IfcSpace&#34;, [])
    
    for space_id in space_ids:
        space = self.properties_index.get(str(space_id))
        if not space:
            continue
            
        # Get storey from cache
        space_storey = self._storey_cache.get(str(space_id))
        
        # If no storey info, include the space in all storeys
        if space_storey is None:
            ids.append(str(space_id))
            print(f&#34;Found space {space_id} (no storey info)&#34;)
        # Otherwise check if the storey name matches
        elif space_storey == storey_name:
            ids.append(str(space_id))
            print(f&#34;Found space {space_id} in storey {storey_name}&#34;)
    
    return ids</code></pre>
</details>
<div class="desc"><p>Return a list of IDs of spaces in a given storey.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>storey_name</code></strong></dt>
<dd>Name of the storey to filter spaces by</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of IDs for spaces in the specified storey</p></div>
</dd>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_storey_for_element"><code class="name flex">
<span>def <span class="ident">get_storey_for_element</span></span>(<span>self, element_id: str) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_storey_for_element(self, element_id: str) -&gt; Optional[str]:
    &#34;&#34;&#34;Get the storey name for an element by its ID.&#34;&#34;&#34;
    return self._storey_cache.get(str(element_id))</code></pre>
</details>
<div class="desc"><p>Get the storey name for an element by its ID.</p></div>
</dd>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_storey_for_space"><code class="name flex">
<span>def <span class="ident">get_storey_for_space</span></span>(<span>self, space_id: str) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_storey_for_space(self, space_id: str) -&gt; Optional[str]:
    &#34;&#34;&#34;Get the storey name for a given space.
    
    Args:
        space_id: The ID of the space
        
    Returns:
        The storey name, or None if not found
    &#34;&#34;&#34;
    return self._storey_cache.get(str(space_id))</code></pre>
</details>
<div class="desc"><p>Get the storey name for a given space.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>space_id</code></strong></dt>
<dd>The ID of the space</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The storey name, or None if not found</p></div>
</dd>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.load_geometry"><code class="name flex">
<span>def <span class="ident">load_geometry</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_geometry(self) -&gt; None:
    &#34;&#34;&#34;Load geometry data for all elements from all files.&#34;&#34;&#34;
    if self._geometry_loaded:
        return
        
    # Handle both list and dict input
    data_list = self.data if isinstance(self.data, list) else [self.data]
        
    for element in data_list:
        element_id = element.get(&#39;ifc_global_id&#39;)
        if not element_id:
            continue
            
        geometry = self._extract_geometry(element)
        if geometry:
            if &#39;geometry&#39; not in self.elements[element_id]:
                self.elements[element_id][&#39;geometry&#39;] = geometry
            else:
                # Merge geometry data
                existing = self.elements[element_id][&#39;geometry&#39;]
                existing[&#39;vertices&#39;] = np.vstack((existing[&#39;vertices&#39;], geometry[&#39;vertices&#39;]))
                existing[&#39;faces&#39;] = np.vstack((existing[&#39;faces&#39;], geometry[&#39;faces&#39;]))
            
    self._geometry_loaded = True</code></pre>
</details>
<div class="desc"><p>Load geometry data for all elements from all files.</p></div>
</dd>
<dt id="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.load_geometry_for_element"><code class="name flex">
<span>def <span class="ident">load_geometry_for_element</span></span>(<span>self, element_id: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_geometry_for_element(self, element_id: str) -&gt; None:
    &#34;&#34;&#34;Load geometry data for a specific element from all files.&#34;&#34;&#34;
    if element_id not in self.elements:
        return
        
    # Handle both list and dict input
    data_list = self.data if isinstance(self.data, list) else [self.data]
        
    elements = [
        e for e in data_list 
        if e.get(&#39;ifc_global_id&#39;) == element_id
    ]
    
    for element in elements:
        geometry = self._extract_geometry(element)
        if geometry:
            if &#39;geometry&#39; not in self.elements[element_id]:
                self.elements[element_id][&#39;geometry&#39;] = geometry
            else:
                # Merge geometry data
                existing = self.elements[element_id][&#39;geometry&#39;]
                existing[&#39;vertices&#39;] = np.vstack((existing[&#39;vertices&#39;], geometry[&#39;vertices&#39;]))
                existing[&#39;faces&#39;] = np.vstack((existing[&#39;faces&#39;], geometry[&#39;faces&#39;]))</code></pre>
</details>
<div class="desc"><p>Load geometry data for a specific element from all files.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qto_buccaneer.utils" href="index.html">qto_buccaneer.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader">IfcJsonLoader</a></code></h4>
<ul class="">
<li><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.add_geometry_files" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.add_geometry_files">add_geometry_files</a></code></li>
<li><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_element" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_element">get_element</a></code></li>
<li><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_elements_by_type" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_elements_by_type">get_elements_by_type</a></code></li>
<li><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_elements_with_property" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_elements_with_property">get_elements_with_property</a></code></li>
<li><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_elements_with_quantity" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_elements_with_quantity">get_elements_with_quantity</a></code></li>
<li><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_geometry" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_geometry">get_geometry</a></code></li>
<li><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_properties" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_properties">get_properties</a></code></li>
<li><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_spaces_in_storey" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_spaces_in_storey">get_spaces_in_storey</a></code></li>
<li><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_storey_for_element" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_storey_for_element">get_storey_for_element</a></code></li>
<li><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_storey_for_space" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.get_storey_for_space">get_storey_for_space</a></code></li>
<li><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.load_geometry" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.load_geometry">load_geometry</a></code></li>
<li><code><a title="qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.load_geometry_for_element" href="#qto_buccaneer.utils.ifc_json_loader.IfcJsonLoader.load_geometry_for_element">load_geometry_for_element</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
